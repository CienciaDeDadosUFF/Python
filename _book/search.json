[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "APRENDIZADO DE MÁQUINA COM PYTHON",
    "section": "",
    "text": "Apresentação\nBreve introdução sobre os objetivos da página, abordagem etc.\n\n\nIntrodução a programação com Python\nFalar o que será abordado aqui\n\n\nAprofundamento em programação com Python\n\n\nConceitos Gerais de Estatística\n\n\nVisualização de Dados\n\n\nEstimativa por Intervalos\n\n\nTeste de Hipóteses Parte 1\n\n\nTeste de Hipóteses Parte 2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Apresentação</span>"
    ]
  },
  {
    "objectID": "caderno1.html",
    "href": "caderno1.html",
    "title": "Introdução a programação com Python",
    "section": "",
    "text": "Conteúdos",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#primeira-execução-do-python",
    "href": "caderno1.html#primeira-execução-do-python",
    "title": "Introdução a programação com Python",
    "section": "Primeira execução do Python",
    "text": "Primeira execução do Python\nTradicionalmente na programação o primeiro código executado quando se instala uma linguagem nova, tanto para aprender quanto em uma nova máquina, é o Hello World. Um programa simples que diz apenas Hello World. O código para isso em Python é:\nprint(\"Hello World\")\nPorém como que diremos para o Python fazer isso? E aonde que ele dirá esse “Hello World”? Ele não tem uma interface visual que nem o Excel que você coloca numa célula uma fórmula que o excel executa.\nExistem duas maneiras de executar um programa no Python: diretamente pelo interpretador e através de um arquivo.\nPara executar diretamente pelo interpretador, pesquise no menu iniciar por Python e abra o aplicativo do Python. Digite o código em Python que quiser depois do &gt;&gt;&gt; e aperte enter.\n\n\n\n\nExecução no interpretador não é muito importante porque não podemos reproduzir o que fizemos de maneira automática. Precisamos reescrever de cabeça cada linha de código que escrevemos anteriormente. A outra alternativa de execução de um código em Python é via um arquivo, onde escrevemos os códigos sequencialmente e eles serão todos executados pelo interpretador em ordem, assim manteremos registro do que foi executado no arquivo que criamos, facilitando ainda sua edição.\nPara executar um código em Python presente em um arquivo precisamos cria-lo com extensão .py e chamar o interpretador para ler o arquivo. Isso pode ser feito rusticamente pelo terminal de comando do seu sistema operacional. Alguns programadores executam códigos apenas dessa maneira. Para quem está iniciando na programação, esse processo é uma dificuldade que pode atrapalhar no processo de aprendizagem.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#ides",
    "href": "caderno1.html#ides",
    "title": "Introdução a programação com Python",
    "section": "IDEs",
    "text": "IDEs\nExistem ferramentas desenvolvidas pela comunidade, algumas até por grandes empresas, com a finalidade de simplificar o processo de se programar em Python. Todas as linguagens de programação possuem alguma ferramenta com essa finalidade. O nome desse tipo de ferramenta é IDE, uma sigla em inglês que significa Integrated Development environment que traduzindo ao português é ambiente de desenvolvimento integrado. As funcionalidades mais comuns de uma IDE é a marcação de texto, que ajuda a legibilidade do código destacando palavras chave da linguagem, explorador de arquivos, que auxilia na criação, remoção e alteração de arquivos, e terminal de comando integrado, um espaço para executar os programas com apenas um botão. A maioria dos programadores profissionais usam alguma IDE. Para a ciência de dados a mais utilizada por desenvolvedores em Python é o Jupyter.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#instalação-e-execução-do-jupyter",
    "href": "caderno1.html#instalação-e-execução-do-jupyter",
    "title": "Introdução a programação com Python",
    "section": "Instalação e execução do Jupyter",
    "text": "Instalação e execução do Jupyter\nPara instalar o Jupyter precisaremos usar o pip, uma ferramenta do Python que permite a instalação de complementos a linguagem mais a frente exploraremos esse assunto melhor. No espaço de pesquisar do windows digite cmd e aperte enter. O cmd é o terminal de comandos do windows, a interface (ou a falta dela) pode assustar assustar um pouco, para o que queremos é só digitar pip install Jupyter e apertar enter, após o comando ser inserido, o terminal irá instalar a extensão do jupyter ao Python. Uma vez instalado o jupyter não precisa ser reinstalado novamente quando for usado.\n\n\nPara cada vez que formos abrir o Jupyter precisamos abrir o terminal de comando, pesquisando cmd na aba de pesquisa do windows e apertando enter, e digitar jupyter notebook e apertar enter. Ao fazer isso, o navegador padrão irá abrir uma aba do Jupyter.\n\nImportante não fechar o prompt de comando que executou o Jupyter, se não o Jupyter para de funcionar.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#hello-world-no-jupyter",
    "href": "caderno1.html#hello-world-no-jupyter",
    "title": "Introdução a programação com Python",
    "section": "Hello World no Jupyter",
    "text": "Hello World no Jupyter\n\nA primeira tela do Jupyter é o explorador de arquivos do seu sistema operacional (no meu caso Windows 11). Aqui você deve selecionar a qual pasta o projeto criado será salvo. Criei a pasta Aprendendo Python. O local ou o nome da pasta que salvará o projeto não é importante, pode ser salva inclusive no diretório inicial que aparece no Jupyter (embora seja recomendado criar uma pasta nova para cada projeto para uma melhor organização).\nPara criar uma pasta ou um arquivo novo no Jupyter basta selecionar o local desejado no explorador de arquivos clicando duas vezes nos caminhos possíveis e depois apertando o botão New e a opção New Folder. Quero criar minha pasta do projeto dentro do meu OneDrive então cliquei duas vezes na pasta OneDrive depois apertei o botão New e selecionei a opção New Folder. Para renomear, deletar, copiar e outras funcionalidades padrões é só apertar com o botão direito em cima da pasta. Cliquei duas vezes na pasta Aprendendo Python que criei e usando uma outra opção do botão New chamada Notebook criei o arquivo que escreveremos nossos programas em Python a partir de agora.\n\nAutomaticamente o Jupyter abrirá uma aba no navegador escrita Select Kernel, selecione a opção “Always start with the preferred kernel” e aperte a opção Select (o Jupyter está perguntando qual versão do Python usar, alguns programadores podem ter mais de uma versão do Python no computador).\n\nAgora estamos finalmente no arquivo que executará programas em Python. Escrevendo print(\"Hello World\") no arquivo e apertando o botão de start o código será executado.\n\n\n\nPodemos ainda executar vários comandos de uma vez só. Veja esse exemplo:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#função-type",
    "href": "caderno1.html#função-type",
    "title": "Introdução a programação com Python",
    "section": "Função type()",
    "text": "Função type()\nAntes de entrar mais especificamente em cada tipo, precisamos falar de uma ferramenta importante. Existe uma função no python que retorna o tipo de uma variável, o type(), que quando usado com o print imprime o tipo na tela. Veja um exemplo:\nx = 4\nprint(type(x))\n\n\n\n\n\n\nclass 'int'\n\n\n\nRepare que uma função pode ser usada dentro de outra. Falaremos mais de funções em breve.\nSabemos que se trata de um int, afinal, nós criamos essa variável. Porém, como muitas coisas na programação, quando se aumenta a escala saber o tipo específico de uma variável em um programa maior ou de outra pessoa pode ser um pouco mais difícil.\nDito isso, podemos agora falar dos principais tipos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#principais-tipos-de-variáveis",
    "href": "caderno1.html#principais-tipos-de-variáveis",
    "title": "Introdução a programação com Python",
    "section": "Principais tipos de variáveis",
    "text": "Principais tipos de variáveis\n\nint\nAbreviação para integer, que traduzido do inglês significa inteiro. São equivalentes a números inteiros da matemática, podendo ser positivos ou negativos e se comportam igual na matemática.\nInstanciação\nSempre que colocamos números sem estar entre aspas estamos instanciando um int:\nx = 4\nprint(x)\nprint(type(x))\n\n\n\n\n\n\n4\nclass 'int'\n\n\n\n\n\nstr\nAbreviação de string, que traduzido do inglês significa fio, corda ou barbante, mas quando usado na programação significa cadeia, uma cadeia de caracteres. Linguagens de programação tradicionalmente possuem o tipo char, que é uma abreviação de characters que traduzido do inglês é caracteres. Esse tipo armazena apenas um caractere textual, o conjunto desses caracteres que é chamado de string. No python, para simplificar, todo dado textual é str.\nInstanciação\nSempre que colocamos caracteres entre aspas simples (’’) ou duplas(““). Podemos também usar”“” “““. Esse último é usado para quando queremos escrever um texto em mais de uma linha de código no python. Segue abaixo exemplos de instanciação:\ntexto1 = \"Ciência de dados!\"\ntexto2 = 'O meu filme favorito é \"troll 2\"!'\ntexto3 = \"\"\"Minha terra tem palmeiras\nOnde canta o Sabiá,\nAs aves, que aqui gorjeiam,\nNão gorjeiam como lá.\"\"\"\n\nprint(texto1)\nprint(type(texto1))\nprint(texto2)\nprint(type(texto2))\nprint(texto3)\nprint(type(texto3))\n\n\n\n\n\n\nCiência de dados!\nclass 'str'\nO meu filme favorito é \"troll 2\"!\nclass 'str'\nMinha terra tem palmeiras\nOnde canta o Sabiá,\nAs aves, que aqui gorjeiam,\nNão gorjeiam como lá.\nclass 'str'\n\n\n\nNote que para usar aspas duplas dentro de uma string (str) precisamos escrever a string entre aspas simples para não terminar precocemente a string, o que resultaria em um erro. O contrário também serve para aspas simples como no apóstrofe da frase em inglês: \"That's life.\".\n\n\nfloat\nAbreviação de floating, que se refere a floating point number ou número de ponto flutuante. São os números racionais da matemática. O nome é uma tecnicalidade da computação referente ao padrão de representação de números racionais no sistema binário dos computadores que não pode ser feito de maneira simples como os números inteiros.\nInstanciação\nSempre que colocamos números com a parte decimal explicita. Diferente do português que usa vírgula, o inglês representa números decimais com pontos:\nnumeroRacional1 = 1.0\nnumeroRacional2 = 56.133000\nprint(numeroRacional1)\nprint(type(numeroRacional1))\nprint(numeroRacional2)\nprint(type(numeroRacional2))\n\n\n\n\n\n\n1.0\nclass 'float'\n56.133\nclass 'float'\n\n\n\nNote que o python por padrão corta os zeros à direita por padrão, ele só mantém o primeiro decimal obrigatóriamente para mostrar que se trata de um float.\n\n\nbool\nEsse aqui é um que é um pouco mais difícil de entender embora seja o mais fácil de se usar. bool é abreviação de boolean e não tem tradução para o português. É um tipo característico da programação e é fundamental devido ao caráter binário das representações em um computador. Sempre será False ou True, assim como no computador tudo é 0 ou 1.\nInstanciação\nPara instanciar, podemos escrever simplesmente True ou False, sem aspas. Outra opção é fazer um teste com operadores lógicos.\nchovendo = True\ncalor = False\nvascoEMaisCampeaoQueOFlamengo = 4 &gt; 7\nprint(chovendo)\nprint(type(chovendo))\nprint(calor)\nprint(type(calor))\nprint(vascoEMaisCampeaoQueOFlamengo)\nprint(type(vascoEMaisCampeaoQueOFlamengo))\n\n\n\n\n\n\nTrue\ntype 'bool'\nFalse\ntype 'bool'\nFalse\ntype 'bool'\n\n\n\nExistem diversos operadores lógicos que analisam sentenças lógicas e retornam um booleano (uma tradução informal para o português). Falaremos deles assim que terminarmos os principais tipos de dados.\n\n\nlist\nAntes de aprender o que é uma list, ou em português lista, precisamos aprender o que é um vetor na computação. Vetores são usados em diversas áreas do conhecimento: matemática, física e biologia. Na escola, nas aulas de matemática e física, aprendemos que vetor tem direção, sentido e módulo. Isso não é bem uma explicação do que é um vetor e sim mais como ele se manifesta. Entender o que é um vetor é um grande desafio para todo aluno do ensino médio. Existe uma definição algébrica complicada do que é um vetor usada na matemática e na física. Nas aulas de biologia existe uma definição mais geral e fácil de entender, que podemos inclusive levar para matemática, para física e para a computação (embora não perfeitamente para esses 3). De maneira geral, vetores são aquilo que carregam alguma coisa. O mosquito aedes aegypti é o vetor da dengue. F é o vetor da física que carrega a força. Na computação, vetores carregam informações e o principal tipo de vetor no python são as listas.\nInstanciação\nPara instanciar uma lista no python usamos colchetes. Separamos diferentes elementos com uso de vírgulas, tudo entre os colchetes:\nvetorDeNumeros = [1, 2, 3, 4]\nvetorDeFrutas = [\"Morango\", \"Pera\", \"Banana\"]\nvetorVazio = [ ]\nprint(vetorDeNumeros)\nprint(type(vetorDeNumeros))\nprint(vetorDeFrutas)\nprint(type(vetorDeFrutas))\nprint(vetorVazio)\nprint(type(vetorVazio))\n\n\n\n\n\n\n[1, 2, 3, 4]\nclass 'list'\n[\"Morango\", \"Pera\", \"Banana\"]\nclass 'list'\n[]\nclass 'list'\n\n\n\nCada linguagem tem sua maneira de representar um vetor. Por padrão, vetores têm tamanho fixo e um único tipo. No python vetores são flexíveis, tanto quanto a tamanho quanto a tipo, uma das razões do porque o python é uma linguagem de programação tão usada nos dias de hoje em ciência de dados e outras áreas da computação.\nIdealmente uma lista recebe apenas um tipo de dado: lista de números inteiros, lista de strings, etc. É mais uma convenção usada por programadores para facilitar o entendimento de um código naqueles projetos maiores que citei algumas vezes.\nExistem outros tipos de vetores além das listas no próprio python: tuple, set, dict. Eles são usados em certas situações mais específicas. Para se aprofundar no python são indispensáveis. Quando chegarmos no uso de ferramentas mais diretas para ciência de dados falaremos um pouco mais.\nUso\nCada elemento de uma lista é acessível usando o nome da lista e colchetes com o índice do elemento na lista começando por 0 (índice zero aponta para o primeiro elemento da lista, uma herança do sistema binário dos computadores no python).\nvetorDeFrutas = [\"Morango\", \"Pera\", \"Banana\"]\nprint(vetorDeFrutas[0])\nprint(vetorDeFrutas[1])\nprint(vetorDeFrutas[2])\n\n\n\n\n\n\nMorango\nPera\nBanana\n\n\n\nSe tentarmos acessar um índice que não existe na lista, digamos, queremos acessar o quarto elemento do vetorDeFrutas acarretará em um erro:\nvetorDeFrutas = [\"Morango\", \"Pera\", \"Banana\"]\nprint(vetorDeFrutas[3])\n\n\n\n\n\n\nTraceback (most recent call last):\nFile \"stdin\", line 1, in module\nIndexError: list index out of range\n\n\n\nEsse erro é bem frequente quando trabalhamos com listas.\nEntendi o que são vetores e sua principal representação no python, as listas e até como usá-las. Mas porque preciso usar? Digamos que você possui um conjunto de matrículas de alunos e um conjunto dos nomes dos alunos. Como você pode representar?\nOpção 1:\nnomeAluno1 = “Anderson” matriculaAluno1 = 123 nomeAluno2 = “Antonio” matriculaAluno2 = 456 nomeAluno3 = “Alexandre” matriculaAluno3 = 789\nOpção 2:\nlistaDeNomes = [“Anderson”, “Antonio”, “Alexandre”] listaDeMatriculas = [123, 456, 789]\nNão ficou mais fácil na segunda opção? Pode não parecer tão fácil assim agora, mas em breve você perceberá isso. Talvez só o uso exaustivo vai mostrar porque a segunda forma é melhor com todos é assim. É mais uma daquelas coisas na programação que quando aumenta a escala fica difícil de manter. No geral, se for usar apenas um nome no código inteiro, use uma variável simples. Se for usar mais de uma, use listas. Isso vale sempre que os dados forem informações relacionadas, nome com nome, fruta com fruta etc.\nMatrizes\nExistem ainda listas de lista, as chamadas matrizes. Matrizes na álgebra podem ser entendidas como conjunto de vetores, na computação é o mesmo entendimento. Elas são particularmente interessantes quando estamos usando um conjunto grande de dados. Imagina que além da matrícula e do nome temos a idade, o curso, o período que entrou na faculdade etc. Podemos ter apenas uma lista que possui todas essas listas.\ncabecalhoInformacoesAlunos = [\"matricula\", \"nome\", \"idade\", \"curso\", \"semestreIngresso\"]\nmatrizInformacoesAlunos = [[123, 456, 789], [\"Anderson\", \"Antonio\", \"Alexandre\"], [20, 18, 33], [\"estatística\", \"direito\", \"medicina\"], [\"2023.1\", \"2019.1\", \"2020.2\"]]\nprint(matrizInformacoesAluno)\n\n\n\n\n\n\n[[123, 456, 789], [\"Anderson\", \"Antonio\", \"Alexandre\"], [20, 18, 33], [\"estatística\", \"direito\", \"medicina\"], [\"2023.1\", \"2019.1\", \"2020.2\"]]\n\n\n\nÉ importante lembrarmos a qual se refere cada lista da matriz, por isso a variável cabecalhoInformacoesAlunos. Em ferramentas específicas para ciência de dados no python isso é feito diretamente, mas no fundo é uma abstração do código a cima. Não preciso nem dizer que isso faz sentido se tivermos um projeto grande, né? A mesma lógica de sempre na programação se aplica aqui também. Assim como sobre quando usar uma variável simples ou uma lista, matrizes são interessantes quando for usar mais de uma lista de dados relacionados, nome de alunos, matrícula de alunos etc. Idealmente uma matriz possui listas de mesmo tamanho, mas isso é uma convenção, não uma regra.\nPara acessar as informações de uma matriz é preciso dois índices entre colchetes.\ncabecalhoInformacoesAlunos = [\"matricula\", \"nome\", \"idade\", \"curso\", \"semestreIngresso\"]\nmatrizInformacoesAlunos = [[123, 456, 789], [\"Anderson\", \"Antonio\", \"Alexandre\"], [20, 18, 33], [\"estatística\", \"direito\", \"medicina\"], [\"2023.1\", \"2019.1\", \"2020.2\"]]\nprint(\"Matrícula e idade do segundo aluno:\")\nprint(matrizInformacoesAlunos[0][1])\nprint(matrizInformacoesAlunos[2][1])\n\n\n\n\n\n\nMatrícula e idade do segundo aluno:\n456\n18\n\n\n\nO primeiro índice é referente a posição da lista na matriz e o segundo índice é a posição do elemento específico na lista desejada. É equivalente ao conceito de colunas e linhas de uma matriz(ij) da matemática. Lembrando que o primeiro índice de uma lista é 0 e não 1.\nPode-se também fazer uma lista de matrizes, que se acessa usando 3 colchetes. Matrizes tem dimensões infinitas no python, mas para ciência de dados comumente usamos apenas 2 dimensões: colunas e linhas. Para computação gráfica, por exemplo, podemos usar mais dimensões e matrizes passam a ser chamadas de tensores. Isso não é importante para ciência de dados, pelo menos não agora (uma pequena antecipação de cenas dos próximos capítulos).\n\n\nfunction\nAs functions, que do inglês significa funções, possuem um conceito semelhante ao da matemática, elas transformam uma informação.\nO print() é um exemplo de função. Ele recebe como argumento um texto e imprime na tela. O type() recebe uma variável qualquer e retorna o seu tipo.\nExiste uma nomenclatura própria para trabalhar com funções, o que a função recebe para trabalhar é o que chamamos de argumentos e o que ela cria a partir desse argumento é o retorno ou resultado. Uma função pode ter mais de um argumento, que são separados por vírgulas. Algumas funções não possuem resultado, o print() por mais que imprima na tela o texto, ele não gera retorno específico, ele é uma função bem especial, por isso falamos dela antes de qualquer outra.\nnomeDaFunção(argumento1, argumento2, …, argumentoN)\nLembra que para imprimir duas informações diferentes em uma mesma linha precisávamos escrever um , end=“” depois do texto no print()? O print tem inúmeros argumentos. O end é um dos argumentos, ele por padrão é um \"\\n\" que faz com que o computador pule uma linha. Argumentos que possuem padrão, se quisermos alterar, precisamos especificá-los, já que não é obrigatório para o funcionamento da função. Quando falarmos mais sobre como criar uma função falaremos mais sobre isso, não precisa entender isso agora.\nChamar uma função X Referenciar uma função\nVenho falando de funções sempre com os parêntesis para diferenciar de outras variáveis normais. Na verdade, os parênteses servem para chamar a função para fazer alguma coisa. Nós podemos referenciar funções apenas pelo seu nome. Por exemplo:\nprint(type(print))\n\n\n\n\n\n\nclass 'builtin_function_or_method'\n\n\n\nEsse código apenas exibe o tipo da variável print, que é uma função. Essa forma de representar funções é útil em códigos mais complexos que usam funções customizadas dentro de outras funções.\nNa referenciação, funções funcionam como qualquer outra variável.\nInstanciação\ndef soma(x, y): return x + y\nComo pode ver é diferente dos demais tipos, usa uma palavra reservada para definir, o def. Para funções, invés de dizer que estamos instanciando, dizemos que estamos definindo-a. Em breve falaremos mais sobre como definir uma função, por enquanto é importante apenas entender que existem algumas funções padrões no python e que podemos criar mais se desejarmos.\n\n\nObjetos\nOs objetos são tipos especiais no python, especiais porque? Nós que o criamos!\nMas nós podemos criar uma função, ou uma String também não? O que tem de especial nisso?\nNós não criamos de fato uma String, nós instanciamos ela, ou seja, criamos exemplos delas. E funções nós definimos, o tipo continua sendo funções.\nNo dicionário li que essas palavras podem ser sinônimos, não estamos falando da mesma coisa?\nNão. São palavras com significado parecido, mas na programação são diferentes.\nEntendi, eu acho…\nEnfim,\nNós definimos uma classe que o objeto pertence e instanciamos a partir dessa classe, essencialmente, essa classe que criamos é um tipo novo, definimos seu comportamento características etc. No próximo caderno falaremos mais sobre elas. Por enquanto vale apenas saber que eles existem.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#e--",
    "href": "caderno1.html#e--",
    "title": "Introdução a programação com Python",
    "section": "+ e -",
    "text": "+ e -\nOs primeiros operadores que aprendemos na escola. O operador + é o operador da adição e - da subtração.\n\nint e float\nEm relação a ints e floats funcionam igual à matemática:\nx = 1 + 3\nprint(x - 2)\n\n\n\n\n\n\n2\n\n\n\nSe somar um inteiro com um float a resposta será sempre um float, nem que seja com .0\nx = 1 + 3.0\nprint(x - 2)\n\n\n\n\n\n\n2.0\n\n\n\n\n\nstr\nPara strings também é possível usar o operador +. Porém diferente de números, como citado anteriormente quando falamos de strings, o + concatena duas strings. Não podemos somar strings a outros tipos.\ntexto = \"ketchup\"\nprint(texto + \" e mostarda\")\n\n\n\n\n\n\nketchup e mostarda\n\n\n\n\n\nbool\nAté dá para usar, mas não serve de muita coisa. O python transforma o valor de True para o inteiro 1 e False para o inteiro 0 e soma como se fosse inteiros\nprint(True + True + False)\n\n\n\n\n\n\n2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#e",
    "href": "caderno1.html#e",
    "title": "Introdução a programação com Python",
    "section": "* e /",
    "text": "* e /\nMultiplicação e divisão respectivamente.\n\nint e float\nFuncionam igual na matemática também, só o símbolo do operador que é diferente.\nx = 4 * 8\nprint(x / 3)\n\n\n\n\n\n\n10.666666666666666\n\n\n\nQuando dividimos dois números inteiros que não possuem valor exato, a resposta é automaticamente convertida para float.\nRepare que a divisão retornou o valor sem aproximação. Por mais que se trate de uma dízima periódica, por conta do funcionamento dos floats nos computadores, o resultado pode vir um pouco diferente do esperado, como no caso, que deveria ter vindo com um 7 no final.\n\n\nstr\nPodemos usar multiplicação em strings. É como se fosse várias operações de adição em sequência, e funcionam igual a adição de strings normal. Não há divisão de strings no python.\ntextoOriginal = \"Ciência de dados!\\n\"\nprint(textoOriginal*5)\n\n\n\n\n\n\nCiência de dados!\nCiência de dados!\nCiência de dados!\nCiência de dados!\nCiência de dados!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#e-1",
    "href": "caderno1.html#e-1",
    "title": "Introdução a programação com Python",
    "section": "// e %",
    "text": "// e %\n// é o operador para divisão inteira e % é o operador de resto da divisão. Digamos que você não queira a parte decimal de uma divisão por alguma razão e quer o resto da divisão também. Funciona apenas para ints e floats.\n25 amigos foram jogar futebol na praça, querem montar equipes de 11 e duas pessoas ficam “na de fora” e entram quando o jogo acabar substituindo alguém do time perdedor. Quantos ficaram na de fora e quantas equipes serão formadas?\nnAmigos = 25\nnEquipes = 25//11\namigosNaDeFora = 25%11\nprint(\"Amigos na de fora:\")\nprint(3)\nprint(\"Equipes formadas:\")\nprint(2)\n\n\n\n\n\n\nAmigos na de fora:\n3\nEquipes formadas:\n2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#section",
    "href": "caderno1.html#section",
    "title": "Introdução a programação com Python",
    "section": "**",
    "text": "**\nExponenciação. Funciona igual a matemática, apenas o símbolo que é novo. Apenas para inteiros e floats. Assim como na matemática, exponenciação pode ser radiciação se usando números menores que 1 como expoentes.\nx = 9\nxAoQuadrado = 9 ** 2\nraizQuadradaDeX = 9 ** 0.5\nprint(xAoQuadrado)\nprint(raizQuadradaDeX)\n\n\n\n\n\n\n81\n3.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#e-2",
    "href": "caderno1.html#e-2",
    "title": "Introdução a programação com Python",
    "section": "( e )",
    "text": "( e )\nColocando assim parece que são dois operadores diferentes, mas na verdade funcionam sempre juntos. São os parêntesis. Funcionam independente do tipo. Colocar uma expressão entre parêntesis significa que ela será executada antes. Seguindo as regras da matemática, exponenciação e radiciação serão sempre feitas antes, multiplicação e divisão em seguida e por último adição e subtração. Usando parêntesis, semelhante a como funciona na matemática, muda essa ordem de prioridade. Os [ ] (colchetes) e { } (chaves) não funcionam que nem na matemática, servem para outras coisas, mas com os parêntesis já podemos fazer qualquer operação na ordem que quisermos.\nexpressaoAlgebrica = (((2+3)/2)+4**2)**(1/2)\nprint(\"Resultado da expressão algébrica (((2+3)/2)+4**2)**(1/2):\")\nprint(expressaoAlgebrica)\n\n\n\n\n\n\nResultado da expressão algébrica (((2+3)/2)+4**2)**(1/2):\n4.301162633521313\n\n\n\n\nfunções\nPara funções funcionam um pouco diferente. Parêntesis executam uma função.\n    print(\"Olá Mundo!\")\n\n\n\n\n\n\nOlá Mundo!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#operadores-condicionais",
    "href": "caderno1.html#operadores-condicionais",
    "title": "Introdução a programação com Python",
    "section": "Operadores condicionais",
    "text": "Operadores condicionais\nOs operadores condicionais são operadores que avaliam uma expressão e retornam um booleano. São eles:\n\n&gt; (maior que)\n&lt; (menor que)\n&gt;= (maior ou igual a)\n&lt;= (menor ou igual a)\n== (igual)\n!= (diferente)\nnot\nand (ou &)\nor (ou |)\nin\n\n\n&gt;, &lt;, &gt;=, &lt;=\nFuncionam quando comparando números (inteiros ou floats) ou quando comparando strings. No caso dos números funcionam igual a matemática. Para strings considera o número de caracteres de cada uma e faz a comparação de tamanho.\n    print(4 &gt; 7)\n    print(5 &lt;= 10.4)\n    print(\"Mostarda\" &gt;= \"Maionese\")\n\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\n== e !=\nPodem ser usados entre diferentes tipos para avaliar se os elementos são iguais, note que “4” é diferente de 4 por conta do tipo.\n    print(4 == 7)\n    print(5 == 5)\n    print(4 != \"4\")\n    print(True != True)\n\n\n\n\n\n\nFalse\nTrue\nTrue\nFalse\n\n\n\n\n\nnot, and, or\nSão usados entre booleanos apenas. Servem para avaliar expressões lógicas mais complexas.\nO not, “não” traduzido do inglês, inverte o booleano de uma expressão.\nO and, “e” traduzido do inglês, precisa ser usado entre duas expressões e retorna True se ambas expressões são verdadeiras e False caso não.\nO or, “e” traduzido do inglês, precisa ser usado entre duas expressões e retorna True se ambas expressões forem verdadeiras ou se uma delas for verdadeira. Se ambas expressões forem falsas retornará False.\nExpressões lógicas precisam estar entre parêntesis quando avaliadas.\n    expressao1 = (1 &lt; 4) and (1 == 0.0)\n    expressao2 = (expressao1) or (\"Mostarda\" == \"Mostarda\")\n    expressao3 = (not expressao1) and (\"Mostarda\" == \"Mostarda\")\n    print(expressao1)\n    print(expressao2)\n    print(expressao3)\n\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\nin\nExclusivo para vetores e strings, muito útil para saber se um elemento está dentro de um vetor ou não, já para strings, se uma string menor está presente em uma string maior.\n    listaDeCodimentos = [\"Ketchup\", \"Mostarda\", \"Maionese\"]\n    print(\"Pimenta\" in listaDeCodimentos)\n    print(\"Mostarda\" in listaDeCodimentos)\n    print(\"ostar\" in listaDeCodimentos[1])\n\n\n\n\n\n\nFalse\nTrue\nTrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#transformação-de-tipo-casting",
    "href": "caderno1.html#transformação-de-tipo-casting",
    "title": "Introdução a programação com Python",
    "section": "Transformação de tipo (casting)",
    "text": "Transformação de tipo (casting)\nO cast, ou transformação de tipo (uma tradução aproximada do inglês), é uma função que existe de uma forma ou outra em qualquer linguagem de programação. Serve para transformar um tipo em outro, simples assim.\nLembra que quando comparamos 4 com “4” usando o operador == recebemos False? Retornará verdadeiro se o tipo fosse o mesmo:\n    print(int(\"4\") == 4)\n\n\n\n\n\n\nTrue\n\n\n\nPara fazer uma transformação de tipo usamos funções com o nome do tipo que queremos receber e dentro do parêntesis o elemento que queremos converter. Como no exemplo, transformamos uma string em um inteiro usando int(). Com booleanos, se uma string não estiver vazia ou se um número inteiro ou float não for 0 (ou 0.0) bool() retornará True e False caso contrário.\n    print(\"4\" == str(4))\n    numeroInteiro = 4\n    numeroRacional = 3.0\n    print(int(numeroRacional))\n    print(float(numeroInteiro))\n    print(bool(numeroInteiro))\n\n\n\n\n\n\nTrue\n3\n4.0\nTrue\n\n\n\nO mesmo serve para converter em strings, floats e booleanos. Entre diferentes tipos de vetores, podemos fazer casts também. Entre listas e tuplas por exemplo, basta usar list() ou tuple()\n    listaDeCodimentos = [\"Mostarda\", \"Ketchup\", \"Maionese\"]\n    print(tuple(listaDeCodimentos))\n\n\n\n\n\n\n('Mostarda', 'Ketchup', 'Maionese')\n\n\n\nNão existe type casting (tipo em inglês + gerúndio de cast, usado as vezes para se referir a transformação de tipos) de funções.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#principais-funções-de-inteiros-int",
    "href": "caderno1.html#principais-funções-de-inteiros-int",
    "title": "Introdução a programação com Python",
    "section": "Principais funções de inteiros (int)",
    "text": "Principais funções de inteiros (int)\n\nrange()\nO range cria um uma sequência numérica com os parâmetros passados.\nSe usarmos apenas um número inteiro na função, a sequência iniciará com 0, terá passo 1 e será até o número anterior ao escrito. Com dois inteiros entre os parêntesis, o primeiro será o início e o segundo o número seguinte ao último da sequência. O terceiro argumento inteiro, que também é opcional, modifica o passo. O resultado da função é um tipo único, o tipo range, que pode ser convertido em lista.\nde0a4 = range(5)\nnumerosDeUmADez = range(1, 11)\nnumerosParesDeZeroAVinte = range(0, 21, 2)\nprint(list(de0a4))\nprint(list(numerosDeUmADez))\nprint(list(numerosParesDeZeroAVinte))\n\n\n\n\n\n\n[0, 1, 2, 3, 4]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n\n\n\nrandom.randint()\nRetorna um número inteiro aleatório dentro de um intervalo, especificado por dois inteiros inseridos.\nUtiliza uma extensão do python chamada random. Para poder usar essa função precisamos escrever import random no início do arquivo python.\nimport random\nnumeroAleatorio1 = random.randint(3, 9)\nnumeroAleatorio2 = random.randint(3, 9)\nnumeroAleatorio3 = random.randint(3, 9)\nnumeroAleatorio4 = random.randint(3, 9)\nprint(numeroAleatorio1)\nprint(numeroAleatorio2)\nprint(numeroAleatorio3)\nprint(numeroAleatorio4)\n\n\n\n\n\n\n3\n4\n7\n7",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#principais-funções-de-floats-float",
    "href": "caderno1.html#principais-funções-de-floats-float",
    "title": "Introdução a programação com Python",
    "section": "Principais funções de floats (float)",
    "text": "Principais funções de floats (float)\n\nround()\nArredonda um número. .5 é arredondado para baixo. O resultado é um número inteiro.\nprint(round(3.3))\nprint(round(2.5))\nprint(round(4.7))\n\n\n\n\n\n\n3\n2\n5\n\n\n\n\n\nmath.ceil()\nArredonda um número racional para cima, ceil é uma palavra do inglês que significa teto.\nUtiliza uma extensão do python chamada math. Para poder usar essa função precisamos escrever import math no início do arquivo python.\nimport math\nprint(math.ceil(3.3))\nprint(math.ceil(2.5))\nprint(math.ceil(4.7))\n\n\n\n\n\n\n4\n3\n5\n\n\n\n\n\nmath.floor()\nArredonda um número racional para baixo, floor é uma palavra do inglês que significa chão\nUtiliza uma extensão do python chamada math. Para poder usar essa função precisamos escrever import math no início do arquivo python.\nimport math\nprint(math.floor(3.3))\nprint(math.floor(2.5))\nprint(math.floor(4.7))\n\n\n\n\n\n\n3\n2\n4\n\n\n\n\n\nmath.trunc()\nSigla para truncate, truncar em português. Remove a parte decimal de um número. Equivalente ao math.floor() para números positivos e equivalente ao math.ceil() para números negativos.\nUtiliza uma extensão do python chamada math. Para poder usar essa função precisamos escrever import math no início do arquivo python.\nimport math\nprint(math.trunc(3.3))\nprint(math.trunc(2.5))\nprint(math.trunc(-4.7))\n\n\n\n\n\n\n3\n2\n-4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#principais-métodos-e-funções-de-strings-str",
    "href": "caderno1.html#principais-métodos-e-funções-de-strings-str",
    "title": "Introdução a programação com Python",
    "section": "Principais métodos e funções de strings (str)",
    "text": "Principais métodos e funções de strings (str)\n\ninput()\nO input recebe uma string que será impressa na tela. Não muito diferente de um print né? A diferença é que o input após imprimir essa string recebe o que digitarmos até apertamos enter.\nEla sempre receberá uma string, então se quisermos inserir números, precisamos fazer uma transformação de tipo depois.\nnome = input(\"Digite seu nome: \\n\")\nidade = int(input(\"Digite sua idade: \\n\"))\nprint(\"Você se chama \" + nome + \" e fará \" + str((idade + 1)) + \" anos\")\n\n\n\n\n\n\nDigite seu nome:\nGabriel\nDigite sua idade:\n23\nVocê se chama Gabriel e fará 24 anos\n\n\n\n\n\nlen()\nSigla para length, que significa comprimento. Recebe uma string ou vetor e retorna quantos caracteres ou elementos possui em int.\nfrase = \"Meu filme favorito é troll 2!\"\nprint(len(frase))\n\n\n\n\n\n\n29\n\n\n\n\n\n.strip()\nRemove espaços no início e no final de uma frase.\nO .strip() é um método, então precisamos colocar a string antes do ponto e, para esse método, não colocamos nada dentro dos parêntesis como parâmetro.\nfrase = \"     Meu filme    favorito é troll 2!                  \"\nprint(frase.strip())\n\n\n\n\n\n\nMeu filme    favorito é troll 2!\n\n\n\n\n\n.replace()\nSubstituir do inglês. Substitui todas as ocorrências de uma string dentro de uma outra string por outra. Muito usada quando queremos remover elementos textuais.\nO .replace() é um método, então precisamos colocar a string antes do ponto e, para esse método, colocamos como parâmetro a string que queremos substituir e em seguida a string nova.\nfrase = \"Meu filme favorito é troll 2 e o meu segundo filme favorito é troll 1!\"\nprint(frase.replace(\"troll\", \"sharknado\"))\n\n\n\n\n\n\nMeu filme favorito é sharknado 2 e o meu segundo filme favorito é sharknado 1!\n\n\n\n\n\n.split()\nDo inglês separar. Separa uma string em várias dado um separador. O resultado é uma lista de strings.\nO .split() é um método, então precisamos colocar a string antes do ponto e, para esse método, colocamos como parâmetro uma string que será usada como separadora. Se não colocarmos nada dentro do split ele considerá por padrão o separador como sendo um espaço.\nfrase = \"Ketchup Maionese Mostarda\"\nlistaDeCodimentosGastronomicos = frase.split(\" \")\nprint(listaDeCodimentosGastronomicos)\n\n\n\n\n\n\n['Ketchup', 'Maionese', 'Mostarda']\n\n\n\n\n\n.format()\nDo inglês formatar. Substitui da string alvo as {} por outras strings.\nO .format() é um método, então precisamos colocar a string antes do ponto e, para esse método, colocamos como parâmetro n strings para n {} na string alvo.\nlistaDeCodimentosGastronomicos = ['Ketchup', 'Maionese', 'Mostarda']\nfrase = \"Codimento Gastronomico 1: {}\\nCodimento Gastronomico 2: {}\\nCodimento Gastronomico 3: {}\".format(listaDeCodimentosGastronomicos[0], listaDeCodimentosGastronomicos[1], listaDeCodimentosGastronomicos[2])\nprint(frase)\n\n\n\n\n\n\nCodimento Gastronomico 1: Ketchup\nCodimento Gastronomico 2: Maionese\nCodimento Gastronomico 3: Mostarda\n\n\n\n\n\n.isalnum(), .isalpha() e .isnumeric()\n.isalnum() retorna True se a string alvo for composta exclusivamente de números e letras. .isalpha() retorna True se a string alvo for composta exclusivamente de letras. .isnumeric() retorna True se a string alvo for composta exclusivamente de números.\nOs três são métodos, então precisamos colocar a string antes do ponto e, para esses métodos, não colocamos nada dentro dos parêntesis como parâmetro.\nprint(\"Troll2\".isalnum())\nprint(\"Ketchup\".isalpha())\nprint(\"Ciência de dados!\".isalpha())\nprint(\"2024\".isnumeric())\nprint(\"Sharknado 5 e troll 2!\".isalnum())\nprint(\"ano de 2024\".isnumeric())\n\n\n\n\n\n\nTrue\nTrue\nFalse\nTrue\nFalse\nFalse\n\n\n\n\n\n.upper(), .lower() e .capitalize()\n.upper() significa superior, transforma todos os caracteres de uma string em caracteres maiúsculos. .lower() significa inferior, transforma todos os caracteres de uma string em caracteres minúsculos. .capitalize() significa capitalizar, transforma o primeiro caracter de uma string em um caractere maiúsculo e os demais em minúsculos.\nOs três são métodos, então precisamos colocar a string antes do ponto e, para esses métodos, não colocamos nada dentro dos parêntesis como parâmetro.\nprint(\"Hello World!\".lower())\nprint(\"ketchup, maionese, mostarda\".upper())\nprint(\"ketchup, maionese, mostarda\".capitalize())\n\n\n\n\n\n\nhello world!\nKETCHUP, MAIONESE, MOSTARDA\nKetchup, maionese, mostarda\n\n\n\n\n\n.join()\nSignifica juntar. Junta uma lista de strings usando uma string comum no meio e retorna como uma string apenas.\nO .join() é um método, então precisamos colocar a string antes do ponto e, para esse método, a string antes do ponto será a string comum que unirá e dentro do parêntesis a lista de strings para unir.\nlistaDeCodimentos = [\"Ketchup\", \"Maionese\", \"Mostarda\"]\nprint(\", \".join(listaDeCodimentos))\n\n\n\n\n\n\nKetchup, Maionese, Mostarda\n\n\n\n\n\n.find()\nDo inglês encontrar. Retorna o índice em que uma string se encontra dentro da outra. Apenas para a primeira ocorrência. Se não encontrar a string, retornará -1.\nO .find() é um método, então precisamos colocar a string antes do ponto e, para esse método, colocamos dentro do parêntesis a string que queremos encontrar dentro da string que referenciamos antes do ponto.\nprint(\"Melhores filmes: Troll 2 e Troll 1\".find(\"Troll\"))\nprint(\"Melhores filmes: Troll 2 e Troll 1\".find(\"Sharknado\"))\n\n\n\n\n\n\n17\n-1\n\n\n\n\n\n.count()\nDo inglês contar. Conta ocorrências de uma string dentro de outra.\nO .count() é um método, então precisamos colocar a string antes do ponto e, para esse método, colocamos dentro do parêntesis a string que queremos contar dentro da string que referenciamos antes do ponto.\nprint(\"Sharknado 1, Sharknado 2, Sharknado 3, Sharknado 4, Sharknado 5, Sharknado 6\".count(\"Sharknado\"))\n\n\n\n\n\n\n6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#principais-métodos-e-funções-de-lista-list",
    "href": "caderno1.html#principais-métodos-e-funções-de-lista-list",
    "title": "Introdução a programação com Python",
    "section": "Principais métodos e funções de lista (list)",
    "text": "Principais métodos e funções de lista (list)\n\nmax()\nDo inglês máximo. Retorna o maior valor da lista inserida entre os parêntesis. Funciona tanto para lista de inteiros quanto lista de racionais\nprint(max([1, 2, 7, 3, 4]))\n\n\n\n\n\n\n7\n\n\n\n\n\nmin()\nDo inglês mínimo. Retorna o menor valor da lista inserida entre os parêntesis. Funciona para listas com qualquer valor numérico, isto é, tanto floats quanto ints.\nprint(min([1, 2, 7, 3, 4]))\n\n\n\n\n\n\n1\n\n\n\n\n\nsum()\nDo inglês somar. Retorna o valor da soma dos elementos da lista. Funciona para listas com qualquer valor numérico, isto é, tanto floats quanto ints.\nprint(sum([1, 2, 7, 3, 4]))\n\n\n\n\n\n\n17\n\n\n\n\n\nlen()\nSemelhante ao len() das strings. Retorna quantos elementos uma lista inserida entre os parêntesis possui.\nprint(len([1, 2, 7, 3, 4]))\n\n\n\n\n\n\n5\n\n\n\n\n\n.append()\nDo inglês acrescentar. Acrescenta um elemento no final de uma lista. Não tem retorno, apenas modifica uma lista já existente.\nO .append() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o elemento que queremos adicionar dentro da lista que referenciamos antes do ponto.\ncodimentosGastronomicos = [\"Ketchup\", \"Maionese\"]\ncodimentosGastronomicos.append(\"Mostarda\")\nprint(codimentosGastronomicos)\n\n\n\n\n\n\n[\"Ketchup\", \"Maionese\", \"Mostarda\"]\n\n\n\n\n\n.extend()\nDo inglês extender. Adiciona os elementos de uma lista a outra. Não tem retorno, apenas modifica uma lista já existente.\nO .extend() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis a lista que possui os elementos que queremos adicionar na que referenciamos antes do ponto.\ncodimentosGastronomicos = [\"Ketchup\", \"Maionese\"]\ncodimentosGastronomicos.extend([\"Mostarda\"])\nprint(codimentosGastronomicos)\n\n\n\n\n\n\n[\"Ketchup\", \"Maionese\", \"Mostarda\"]\n\n\n\n\n\n.insert()\nDo inglês inserir. Insere um elemento dentro de uma lista no índice fornecido. Se o índice for maior que o número de elementos da lista, será adicionado no final da lista. Não tem retorno, apenas modifica uma lista já existente.\nO .insert() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o índice seguido do elemento que queremos adicionar.\ncodimentosGastronomicos = [\"Ketchup\"]\ncodimentosGastronomicos.insert(231, \"Mostarda\")\ncodimentosGastronomicos.insert(1, \"Maionese\")\nprint(codimentosGastronomicos)\n\n\n\n\n\n\n[\"Ketchup\", \"Maionese\", \"Mostarda\"]\n\n\n\n\n\n.remove()\nDo inglês remover. Remove a primeira ocorrência de um elemento de uma lista. Não tem retorno, apenas modifica uma lista já existente.\nO .remove() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o elemento que queremos remover.\ncodimentosGastronomicos = [\"Ketchup\", \"Maionese\", \"Mostarda\"]\ncodimentosGastronomicos.remove(\"Ketchup\")\nprint(codimentosGastronomicos)\n\n\n\n\n\n\n[\"Maionese\", \"Mostarda\"]\n\n\n\n\n\n.pop()\nDo inglês disparar. Retorna o elemento da lista apontado pelo índice fornecido e o remove da lista.\nO .pop() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o índice elemento que queremos remover. Se não colocarmos nenhum índice, o último elemento será removido.\ncodimentosGastronomicos = [\"Ketchup\", \"Maionese\", \"Mostarda\"]\ncodimentosGastronomicos.pop(1)\nprint(codimentosGastronomicos)\nprint(codimentosGastronomicos.pop())\nprint(codimentosGastronomicos)\n\n\n\n\n\n\n['Ketchup', 'Mostarda']\nMostarda\n['Ketchup']\n\n\n\n\n\n.index()\nDo inglês índice. Retorna o índice da primeira ocorrência do elemento entre os parêntesis.\nO .index() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o elemento que queremos o índice. Se o elemento não estiver na lista resultará em um erro.\ncodimentosGastronomicos = [\"Ketchup\", \"Maionese\", \"Mostarda\"]\nprint(codimentosGastronomicos.index(\"Ketchup\"))\n\n\n\n\n\n\n0\n\n\n\n\n\n.count()\nSemelhante ao .count das strings. Retorna o número de ocorrências do elemento em uma lista.\nO .count() é um método, então precisamos colocar a lista antes do ponto e, para esse método, colocamos dentro do parêntesis o elemento que queremos contar.\nlista = [\"Ciência de dados!\", \"Ciência de dados!\", \"Ciência de dados!\", \"Ciência de dados!\"]\nprint(lista.count(\"Ciência de dados!\"))\n\n\n\n\n\n\n4\n\n\n\n\n\n.sort() ou sorted()\nDo inglês organizar e organizado. Rearruma uma lista de números organizando ela por ordem crescente ou decrescente. Funciona para listas que contém apenas números inteiros e racionais e para listas que contém apenas strings (organiza por ordem alfabética nesse caso).\nPor padrão será de ordem crescente, mas se colocarmos reverse=True como parâmetro, será em ordem decrescente.\n.sort() é um método que altera uma lista já existente, sorted() é uma função que retorna uma lista nova organizada.\nnumeros1 = [5, 1, 77, 8, 2, 3, 3213, 23, -3, -7]\nnumeros1.sort(reverse=True)\nnumeros2 = [5, 1, 77, 8, 2, 3, 3213, 23, -3, -7]\nnumeros2 = sorted(numeros2)\nlistaDeCodimentos = [\"Ketchup\", \"Mostarda\", \"Maionese\"]\nprint(numeros1)\nprint(numeros2)\nprint(sorted(listaDeCodimentos))\n\n\n\n\n\n\n[3213, 77, 23, 8, 5, 3, 2, 1, -3, -7]\n[-7, -3, 1, 2, 3, 5, 8, 23, 77, 3213]\n['Ketchup', 'Maionese', 'Mostarda']\n\n\n\n\n\n.reverse()\nDo inglês inverso. Inverte a ordem de uma lista. Não gera retorno, apenas altera uma lista já existente.\nÉ um método.\nlistaDeCodimentos = [\"Ketchup\", \"Maionese\", \"Mostarda\"]\nlistaDeCodimentos.reverse()\nprint(listaDeCodimentos)\n\n\n\n\n\n\n['Mostarda', 'Maionese', 'Ketchup']",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#comentários-com-hashtag",
    "href": "caderno1.html#comentários-com-hashtag",
    "title": "Introdução a programação com Python",
    "section": "Comentários com hashtag",
    "text": "Comentários com hashtag\nPrincipal forma de comentar um código no python. Deixa tudo que está depois do caractere # comentado. Pode ser usado no início de uma linha ou no meio, no segundo caso, apenas o que está depois do # será comentado.\nIdeal para explicar o funcionamento de uma parte do código e para deixar salvo algo que não foi utilizado mas que pode ser utilizado no futuro.\n#Lista de codimentos mais utilizados na cozinha brasileira\nlistaDeCodimentos = [\"Maionese\", \"Mostarda\", \"Ketchup\"]\n#Organiza em ordem alfabética\nlistaDeCodimentos.sort()\n#Inverte a ordem dos codimentos (não vou utilizar agora)\n#listaDeCodimentos.reverse()\nprint(listaDeCodimentos)\n\n\n\n\n\n\n['Ketchup', 'Maionese', 'Mostarda']",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno1.html#comentários-com",
    "href": "caderno1.html#comentários-com",
    "title": "Introdução a programação com Python",
    "section": "Comentários com ““” ““”",
    "text": "Comentários com ““” ““”\nMenos usado. Na verdade, não é comentário de verdade, o interpretador lê as frases entre as 3 aspas como se fosse uma string normal, porém não faz nada. Pode ser usado para comentar de maneira rápida muitas linhas de código.\nOutro uso é para definir funções e classes. As IDEs usam essa string para ajudar na reutilização da função ou classe. Usar \"\"\" \"\"\" no início da definição de uma função ou classe permite que esse comentário seja visto pela dica flutuante ao escrever uma função em um código dentro de uma IDE.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução a programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html",
    "href": "caderno2.html",
    "title": "Aprofundamento em programação com Python",
    "section": "",
    "text": "Conteúdos",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html#if",
    "href": "caderno2.html#if",
    "title": "Aprofundamento em programação com Python",
    "section": "if",
    "text": "if\nQuando falamos em tomar decisões, a estrutura que trabalhamos é sempre o if, que é uma estrutura que testa condições impostas para decidir como prosseguir em certas situações, como por exemplo checar se um número é maior, menor ou igual a outro. Testando uma condição única:\nif 10 &lt; 30:\n    print('10 é menor que 30')\n\n\n\n\n\n\n10 é menor que 30\n\n\n\nPodemos também testar múltiplas condições exigindo que todas sejam verdadeiras ou apenas uma seja, dependendo do operador usado: or ou and. Precisamos separar essas diferentes condições usando parentêsis.\nO operador or, “ou” traduzindo do inglês, faz com que a condição seja satisfeita se a primeira ou a segunda expressão (ou as duas) forem verdadeiras. Pode ser também representado pelo caractere |\nif (7 &lt; 3) or (5 &gt; 1):\n    print('Pelo menos um é verdade')\n\n\n\n\n\n\nPelo menos um é verdade\n\n\n\nJá o operador and, “e” traduzindo do inglês, faz com que a condição seja satisfeita se a primeira e a segunda expressão sejam verdadeiras Pode ser também representado pelo caractere &\nif (7 == 7) and (5 &gt; 1):\n    print('Ambas expressões são verdadeiras')\n\n\n\n\n\n\nAmbas expressões são verdadeiras",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html#else",
    "href": "caderno2.html#else",
    "title": "Aprofundamento em programação com Python",
    "section": "else",
    "text": "else\nPara toda situação sempre podemos incluir uma saída padrão como resposta se a condição não for satisfeita, para isso temos o else.\nn = 40\nif n &lt; 30:\n    print('%i é menor que 30'%(n))\nelse:\n    print('%i é maior ou igual a 30'%(n))\n\n\n\n\n\n\n40 é menor maior ou igual a 30",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html#elif",
    "href": "caderno2.html#elif",
    "title": "Aprofundamento em programação com Python",
    "section": "elif",
    "text": "elif\nPodemos também incluir mais de uma condição a ser testada, adicionando mais instâncias do if ao mesmo if com a estrutura elif.\nn = 40\nif n &lt; 30:\n    print('%i é menor que 30'%(n))\nelif n &gt; 30:\n    print('%i é maior que 30'%(n))\nelse:\n    print('%i é igual a 30'%(n))\n\n\n\n\n\n\n40 é maior que 30",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html#for",
    "href": "caderno2.html#for",
    "title": "Aprofundamento em programação com Python",
    "section": "for",
    "text": "for\nO for é uma estrutura de repetição que percorre um escopo de valores específicos, por exemplo se queremos printar os números de 0 até 10 podemos escrever desta forma:\nfor numero in range(0,10):\n    print(numero)\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nNote que o primeiro número impresso é o 0 como especificado e o último número o 9. A variável numero armazena o valor de cada iteração do loop, mas o for sempre para antes do último número, que seria o 10, porque o Python é uma linguagem que começa com 0 invés de 1, e descartar esse último número auxilia na hora de iterar listas, a principal razão do uso do laço for. Observe como percorrer os elementos de uma lista:\nmeses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun']\nfor i in range(length(meses)):\n    print(meses[i])\n\n\n\n\n\n\njan\nfev\nmar\nabr\nmai\njun\n\n\n\nPor convenção, no python usamos como variável do loop o i se quisermos percorrer uma lista. Usar um for dentro de outro serve para percorrer uma matriz. Nesse caso usaremos j no segundo. Se mais uma dimensão for adicionada será k. Para ordens ainda maiores não existe uma convenção, porém, eu utilizo o alfabeto invés de i, j, k.\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfor i in range(length(matriz)):\n    for j in range(length(matriz[i])):\n        print(matriz[i][j])\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nExiste uma alternativa ao range de como percorrer uma lista com o for. O range cria esses índices para serem referenciados na lista. Podemos salvar os elementos direto na variável do loop como feito a seguir:\nmeses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun']\nfor mes in meses:\n    print(mes)\n\n\n\n\n\n\njan\nfev\nmar\nabr\nmai\njun\n\n\n\nO problema de usar o loop dessa forma é que não podemos alterar a lista original já que perdemos a referência numérica dela. Existem situações que o primeiro método é preferível e situações que o segundo método é preferível.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "caderno2.html#while",
    "href": "caderno2.html#while",
    "title": "Aprofundamento em programação com Python",
    "section": "while",
    "text": "while\nO while é um loop que enquanto uma condição não for satisfeita ou enquanto ela for satisfeita esse loop permanecerá ocorrendo, usado principalmente quando o número de iterações do loop não é definido por um número e sim por uma condição.\nanimais = ['cachorro', 'gato', 'rato', 'macaco', 'cachorro', 'cachorro', 'elefante', 'leao']\nwhile 'cachorro' in animais:\n    animais.remove('cachorro')\nprint(animais)\n\n\n\n\n\n\n['gato', 'rato', 'macaco', 'elefante', 'leao']\n\n\n\nRepare que 'cachorro' foi removido mais de uma vez da lista de animais. Uma vez que não haviam mais cachorros na lista de animais, o loop do while foi finalizado.\n\nbreak e flags\nPodemos interromper o while utilizando o break ou flags, como nos exemplos abaixo:\n# Saudando pessoas até que elas queiram sair do programa com o break\nwhile True:\n    resposta = input('Digite seu nome para que eu possa te dar um oi!:\\n'+'(Entre com \"quit\" para sair da aplicacao)\\n\\n')\n    \n    if resposta.lower() == 'quit':\n        break\n    # SE CAIR NA CONDIÇÃO DO `BREAK` AS LINHAS ABAIXO DESTE COMENTÁRIO NÃO SERÃO EXECUTADAS!!!\nprint('Olá, ' + resposta)\n\n\n\n\n\n\nOlá quit\n\n\n\nUm exemplo com flags que são variáveis booleanas que controlam o fluxo.\ncontinuar_execucao = True\nwhile continuar_execucao:\n    resposta = input('Digite seu nome para que eu possa te dar um oi!:\\n'+'(Entre com \"quit\" para sair da aplicacao)\\n\\n')\n    if resposta.lower() != 'quit':\n        print('Olá, ' + resposta)\n    else:\n        continuar_execucao = False\n\n\n\n\n\n\nOlá quit\n\n\n\n\n\ncontinue\nTambém podemos dar continuidade a um ciclo com a utilização do continue.\nwhile True:\n    resposta = input('Digite seu nome para que eu possa te dar um oi!:\\n' + '(Entre com \"quit\" para sair da aplicacao)\\n\\n')\n    if resposta == '':\n        print('Digite um nome válido!')\n        continue\n    # SE O USUÁRIO APENAS PRECIONAR ENTER SEM ADICIONAR SEU NOME O CICLO REINICIARÁ E PEDIRA NOVAMENTE PARA QUE\n    # DIGITE SEU NOME.\n    if resposta.lower() == 'quit':\n        break\n    # SE CAIR NA CONDIÇÃO DO `BREAK` AS LINHAS ABAIXO DESTE COMENTÁRIO NÃO SERÃO EXECUTADAS!!!\n    print('Olá, ' + resposta)\n\n\n\n\n\n\nDigite um nome válido!\n\n\n\nRepare que o print('Olá, ' + resposta) não foi feito porque na primeira iteração o loop caiu no continue e no segundo no break porque o quit foi digitado.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aprofundamento em programação com Python</span>"
    ]
  },
  {
    "objectID": "ConceitosGeraisDeEstatistica.html",
    "href": "ConceitosGeraisDeEstatistica.html",
    "title": "4  Conceitos Gerais de Estatística",
    "section": "",
    "text": "Conteúdos\nNeste capítulo vamos definir algumas distribuições de probabilidade que são consideradas como as mais conhecidas e as mais utilizadas nos processos de construção de Intervalos de Confiança e Testes de Hipóteses. Discutiremos sobre suas definições, seus parâmetros e seus usos no meio prático. Saber identificar se os dados seguem certa distribuição segue como um dos principais passos para se aplicar um teste de hipóteses.\nDado que o espaço amostral, representado pela letra grega , é definido como o conjunto formado por todos os possíveis resultados de um experimento aleatório, definimos como uma variável aleatória (v.a.) a função que associa cada elemento de a um número real.\nUma variável aleatória pode ser discreta quando o conjunto dos possíveis valores (imagem) for finito ou enumerável, ou contínua quando o conjunto dos possíveis valores for não enumerável, por exemplo intervalos na reta. O foco será nas variáveis aleatórias contínuas.\nDistribuições Contínuas As distribuições contínuas descrevem o comportamento dos possíveis valores de uma variável aleatória contínua. Dentre as distribuições contínuas conhecidas, iremos apresentar:\nDefina-se a probabilidade de ocorrência sendo a área calculada sob a curva, ou seja, a probabilidade de uma observação assumir um valor entre dois pontos quaisquer equivale a área compreendida entre esses dois pontos. Através disso, dado que X é uma variável aleatória contínua e A um intervalo pertencente aos reais, definimos f sendo sua função de densidade de probabilidade (f.d.p) de forma que:\n\\(P(X \\in A) = \\int_A f(x)dx\\)\nPara que a função f seja uma legítima função de densidade de probabilidade ela deve satisfazer as seguintes propriedades:\nA Distribuição Normal é uma das mais importantes entre as distribuições contínuas. Sua importância se deve a vários fatores, dentre eles temos o Teorema Central do Limite (TCL), o qual é um resultado fundamental em aplicações práticas e teóricas, pois ele garante que, mesmo que os dados não sejam distribuídos segundo uma normal, a distribuição da média amostral dos dados se comporta como uma distribuição normal conforme o número de dados aumenta. Diversos estudos práticos tem como resultado uma distribuição normal, como por exemplo a altura de uma certa população em geral.\nDiz-se que, uma variável aleatória contínua X, definida para todos os valores nos reais, tem Distribuição Normal com parâmetros µ e σ², onde −∞ &lt; µ &lt; ∞ e 0 &lt; σ² &lt; ∞, se sua função densidade de probabilidade é dada por:\n\\(f(x)=\\frac{1}{\\sqrt{2\\pi \\sigma ^{2}}}exp\\left [ -\\frac{(x-\\mu )^2}{2\\sigma ^{2}} \\right ] ,onde -\\infty &lt; x &lt; +\\infty\\)\nOs parâmetros e ² são a média e a variância da distribuição Normal, respectivamente. Usaremos a seguinte notação para indicar que X tem distribuição normal com parâmetros µ e σ²: X ∼ N(µ, σ²).\nUma das características da distribuição Normal é que ela é simétrica em torno de sua média , ou seja, há 50% de probabilidade acumulada à esquerda e à direita da média. Outra característica é o seu formato de “sino”, a seguir ilustramos esse comportamento através das densidades X ~ N(0,1), X ~ N(0,2) e X ~ N(3,1).\nNota-se que os dois parâmetros influenciam na caracterização das densidades. Assim temos:\nComo exemplo vamos plotar o histograma de uma amostra aleatória de distribuição normal de tamanho 1000 que representa os pesos dos homens de uma população de uma certa cidade, com 𝜇 = 80 e 𝜎² = 4 junto a sua curva de densidade.\nPara utilizar a função nr.normal() para gerar números aleatórios de uma distribuição normal, deve-se ter atenção aos seus principais argumentos de entrada:\nUtilizando essa mesma distribuição, onde X ~ N(80,4), vamos calcular algumas probabilidades:\nPara calcular a densidade de probabilidade deve ser utilizada a função norm.pdf(). Para exemplificar, iremos calcular a densidade de probabilidade no ponto x = 80, ou seja, \\(f(x = 80)\\)\nPara calcular a probabilidade acumulada até um certo ponto, utilizamos a função norm.cdf(). Para exemplificar, calcularemos a probabilidade acumulada \\(P(x&lt;80)\\). .\nPara calcular um percentil dessa distribuição, utilizamos a função norm.ppf(). Para exemplificar, calcularemos o percentil 75, ou seja, achar o k, tal que \\(P(X≤k)=0.75\\). .\nA distribuição exponencial é muito útil para descrever o tempo que se leva para completar uma tarefa ou tempo de duração de um equipamento. Como exemplos de aplicações temos:\nUma variável aleatória X contínua tem distribuição exponencial com parâmetro λ &gt; 0 se sua função densidade de probabilidade é dada por:\n\\(f(x) = \\begin{cases} \\lambda e^{-\\lambda x} & x\\geq 0 \\\\ 0 & x&lt;0 \\end{cases}\\)\nOnde λ é o parâmetro da densidade exponencial, e denotamos por X ~ exp(λ). Dentre suas propriedades temos que a média da distribuição é igual a 1/λ. A seguir podemos visualizar A seguir podemos visualizar o comportamento da densidade para diferentes valores de λ.\nComo exemplo iremos plotar o histograma de uma amostra aleatória de distribuição exponencial de tamanho 500 onde X é o tempo(em minutos) para realizar uma prova de Cálculo 1A na UFF, com λ = 1/90 junto a sua curva de densidade.\nPara gerar números provenientes de uma exponencial com λ=1/90, utiliza-se a função nr.exponencial sendo os principais argumentos de entrada:\nUtilizando essa mesma distribuição, onde X ~ exp(1/90), vamos calcular algumas probabilidades:\nPara calcular a densidade de probabilidade deve-se utilizar a função expon.pdf(). Para exemplificar, vamos calcular a densidade de probabilidade em x = 3, ou seja, \\(f(x=3)\\).\nPara calcular a probabilidade acumulada até um ponto, utiliza-se a função expon.cdf(). Para exemplificar, vamos calcular a probabilidade acumulada \\(P(x&lt; 200)\\):\nCaso queira calcular o percentil da distribuição utilize a função expon.ppf(). Para exemplificar, vamos calcular o percentil 50 dessa distribuição, ou seja, descobrir o k, tal que \\(P(X≤k)=0.5\\).\nA distribuição t de Student é considerada uma das distribuições mais utilizadas na estatística com aplicações que vão desde a modelagem de dados até aplicações de Testes de Hipóteses.\nDizemos que X tem distribuição de t de Student com n graus de liberdade se sua função de densidade de probabilidade é dada por:\n\\(f(x)=\\frac{\\Gamma (\\frac{n+1}{2})}{\\sqrt{n\\pi }\\Gamma(\\frac{n}{2})} \\left( 1+\\frac{x^2}{n} \\right )^{-\\left ( \\frac{n+1}{2} \\right )}, onde -\\infty &lt;x&lt;+\\infty\\)\nUtilizamos a notação X ~ , onde . A seguir ilustramos a densidade para diferentes graus de liberdade:\nPropriedades:\nPara exemplificar, nós iremos plotar o histograma de uma amostra aleatória de distribuição T de Student de tamanho 1000 com 15 graus de liberdade, junto a sua curva de densidade.\nUtilizando essa mesma distribuição, onde X ~ , vamos calcular algumas probabilidades:\nPara calcular a densidade de probabilidade deve ser utilizada a função t.pdf(). Para exemplificar, iremos calcular a densidade de probabilidade no ponto x = 0.5, ou seja, \\(f(x = 0.5)\\).\nPara calcular a probabilidade acumulada até um certo ponto, utilizamos a função t.cdf(). Para exemplificar, calcularemos a probabilidade acumulada \\(P(x &lt; 1)\\). .\nPara calcular um percentil dessa distribuição, utilizamos a função t.ppf(). Para exemplificar, calcularemos o percentil 75, ou seja, achar o k, tal que \\(P(X ≤ k) = 0.75\\).\nA distribuição qui-quadrado será muito importante para quando tratarmos de Intervalo de Confiança e Teste de Hipótese para variância populacional.\nSeja X uma variável aleatória contínua que assume somente valores positivos, temos que X segue uma distribuição Qui-Quadrado com n graus de liberdade se sua função de densidade é dada por:\n\\(f(x)=\\frac{1}{2^{\\frac{n}{2}}\\Gamma(\\frac{n}{2})}x^{(\\frac{n}{2})-1}exp\\left ( -\\frac{x}{2} \\right ); n&gt;0, x&gt;0\\)\nA notação utilizada é X ~ ² . A seguir ilustramos como se caracteriza a densidade com diferentes graus de liberdade:\nApós apresentados os gráficos e a fórmula de densidade de probabilidade, temos que a Qui-Quadrado é um caso especial da distribuição Gama com α = n/2 e β = 2. Para saber mais sobre a Distribuição Gama, clique aqui (link quebrado)\nComo exemplo, vamos observar uma amostra aleatória de tamanho 1000 proveniente de um distribuição qui-quadrado com 5 graus de liberdade, junto a sua curva de densidade.\nUtilizando essa mesma distribuição, onde X ~ \\(X²_{5}\\) , vamos calcular algumas probabilidades:\nPara calcular a densidade de probabilidade deve ser utilizada a função chi2.pdf(). Para exemplificar, iremos calcular a densidade de probabilidade no ponto x = 5, ou seja, \\(f(x = 5)\\).\nPara calcular a probabilidade acumulada até um certo ponto, utilizamos a função chi2.cdf(). Para exemplificar, calcularemos a probabilidade acumulada \\(P(x &lt; 4)\\).\nPara calcular um percentil dessa distribuição, utilizamos a função chi2.ppf(). Para exemplificar, calcularemos o percentil 75, ou seja, achar o k, tal que \\(P(X ≤ k) = 0.75\\).\nA distribuição F será fundamental para análise de variâncias que será apresentado nos próximos capítulos.\nUma variável aleatória contínua X possui distribuição F de Snedecor com m e n graus de liberdade se sua função de densidade é definida por:\n\\(f(x) = \\frac{\\Gamma(\\frac{\\nu_{1} + \\nu_{2}} {2}) (\\frac{\\nu_{1}} {\\nu_{2}})^{\\frac{\\nu_{1}} {2}} x^{\\frac{\\nu_{1}} {2} - 1 }} {\\Gamma(\\frac{\\nu_{1}} {2}) \\Gamma(\\frac{\\nu_{2}} {2}) (1 + \\frac{\\nu_{1}x} {\\nu_{2}})^{\\frac{\\nu_{1} + \\nu_{2}} {2}} }\\)\nNeste caso, utilizamos a notação , onde e . A seguir podemos visualizar como se caracteriza a densidade dessa distribuição quando o valor de = 20 e varia entre 1,10 e 50.\nPropriedade: Sejam U e V duas variáveis aleatórias independentes tais que U ~ \\(X^{2}{m}\\) e \\(X^{2}{n}\\) . Seja:\n\\(W=\\frac{\\frac{U}{m}}{\\frac{V}{n}}\\sim F_{m,n}\\)\nTemos que W tem distribuição F de Snedecor com m e n graus de liberdade. Assim, tem-se que os graus de liberdade da distribuição F referem-se aos graus de liberdade das duas variáveis Qui-quadrado.\nPara exemplificar, vamos observar uma amostra aleatória de tamanho 10000 proveniente de um distribuição F com m = 20 e n = 50, junto a sua curva de densidade.\nUtilizando essa mesma distribuição, onde \\(X\\sim F_{20,50}\\), vamos calcular algumas probabilidades:\nPara calcular a densidade de probabilidade deve ser utilizada a função f.pdf(). Para exemplificar, iremos calcular a densidade de probabilidade no ponto x = 1, ou seja, \\(f(x = 1)\\).\nPara calcular a probabilidade acumulada até um certo ponto, utilizamos a função f.cdf(). Para exemplificar, calcularemos a probabilidade acumulada \\(P(x &lt; 1.5)\\)\nPara calcular um percentil dessa distribuição, utilizamos a função f.ppf(). Para exemplificar, calcularemos o percentil 75, ou seja, achar o k, tal que \\(P(X ≤ k) = 0.75\\).\nProcedimento de seleção de amostras que considera que todas as amostras de tamanho n tem a mesma chance (global) de seleção, podendo ser realizado com reposição ou sem reposição. Uma amostra aleatória de tamanho n de uma variável aleatória X com distribuição de probabilidade \\(f\\) é o conjunto formado pelas variáveis \\(X_{1}, X_{2}, \\ldots , X_{n}\\) independentes e identicamente distribuídas com \\(f\\).\nObtida uma amostra aleatória, é possível definir funções reais da amostra aleatória. Como o seu valor depende da amostra sorteada, uma função da amostra aleatória também é uma variável aleatória. Por exemplo, a média amostral é a variável aleatória definida por:\n\\(\\bar{X}=\\frac{X_{1}+X_{2}+X_{3}+…+X_{n}}{n}\\)\nOutro exemplo é a variância amostral:\n\\(S^{2}=\\frac{1}{n-1}\\sum\\limits_{i=i}^{n}\\left ( X_{i} - \\bar{X} \\right )^{2}\\)\nDizemos que uma estatística ou estimador T é qualquer função da amostra \\(X_{1}, X_{2}, \\ldots , X_{n}\\) que não depende dos parâmetros da distribuição f, isto é,\n\\(T = g(X_{1}, X_{2}, \\ldots , X_{n})\\)\nA distribuição amostral de uma estatística T é a função de probabilidade de T ao longo de todas as possíveis amostras de tamanho n.\nNos problemas de inferência, estamos interessados em estimar um parâmetro θ da população (por exemplo, a média populacional) através de uma amostra aleatória simples \\(X_{1}, X_{2}, \\ldots , X_{n}\\). Para isso, usamos uma estatística T (por exemplo, a média amostral) e, com base no valor obtido para T a partir de uma particular amostra, iremos tomar as decisões que o problema exige.\nAgora vamos descrever alguns exemplos de distribuições amostrais:\nDistribuição da Média Amostral: Seja \\(X_{1}, X_{2}, \\ldots , X_{n}\\) uma amostra aleatória simples de tamanho n de uma população normal, isto é, uma população representada por uma variável aleatória normal \\(X ∼ N(µ; σ²)\\). Então, a distribuição da média amostral \\(\\bar{X}\\) é normal com média µ e variância \\(\\frac{\\sigma^{2}}{n}\\), ou seja,\n\\(X ∼ N(µ; σ^{2})⇒ \\bar{X} ∼ N(µ;\\frac{\\sigma^{2}}{n})\\)\nA seguir ilustramos esse comportamento através de uma amostra aleatória simples de tamanho 25:\nEm azul temos uma amostra de tamanho 1 e em vermelho, 25. Veja que os dados ficam mais “concentrados”, ou seja, a variância decai conforme o tamanho da amostra aumenta, o que estabelece um formato de “sino” mais estreito ao gráfico. Isso ocorre através do efeito de escala determinado pela variância da distribuição.\nDistribuição Amostral de \\(\\sum\\limits_{i=1}^n\\left(\\frac{X_i-\\mu_i}{\\sigma_i}\\right)^2\\): Seja \\(X_{1}, X_{2}, . . . , X_{n}\\) uma amostra aleatória simples de tamanho n de uma população normal, isto é, uma população representada por uma variável aleatória normal \\(X ∼ N(µ; σ²)\\) e \\(S^2\\) a variância amostral. Então, a distribuição amostral da variância \\(\\frac{(n - 1)S^2}{\\sigma^2}\\) é Qui-Quadrado com \\(n-1\\) graus de liberdade.\n\\(\\frac{(n - 1)S^2}{\\sigma^2} \\sim X^2_{n-1}\\)\nEsse resultado será muito importante para os próximos cadernos, quando trataremos do Intervalo de Confiança e Teste de Hipótese para variância.\nFARIAS, A. M. L. KUBRUSLY, J. SOUZA, M.A.O. Probabilidade e Variáveis Aleatórias Unidimensionais. Departamento de Estatística. Universidade Federal Fluminense. Velarde, L. G. C. CAVALIERE, Y. F. Apostila Inferência Estatística. Departamento de Estatística. Universidade Federal Fluminense FARIAS, A. M. L. Apostila de Estatística II. Departamento de Estatística. 2017. Universidade Federal Fluminense."
  },
  {
    "objectID": "ConceitosGeraisDeEstatistica.html#scipy",
    "href": "ConceitosGeraisDeEstatistica.html#scipy",
    "title": "4  Conceitos Gerais de Estatística",
    "section": "SciPy",
    "text": "SciPy\nO SciPy é o pacote básico da linguagem Python que implementa diversas técnicas úteis na computação científica. Utilizaremos essa biblioteca para calcular as probabilidades, construir Intervalos de Confiança e aplicar Testes de Hipóteses."
  },
  {
    "objectID": "ConceitosGeraisDeEstatistica.html#importação",
    "href": "ConceitosGeraisDeEstatistica.html#importação",
    "title": "4  Conceitos Gerais de Estatística",
    "section": "Importação",
    "text": "Importação\nSerão importados os seguintes pacotes para gerar variáveis aleatórias, calcular as probabilidades e plotar gráficos.\nimport numpy.random as nr #Gerador de amostras aleatórias\nimport numpy as np \nimport scipy.stats as ss #Principal ferramenta para os cálculos de probabilidades.\nfrom scipy.special import gamma # função Gama\nimport matplotlib.pyplot as plt #Construção de Gráficos"
  },
  {
    "objectID": "VisualizacaoDeDados.html",
    "href": "VisualizacaoDeDados.html",
    "title": "5  Visualização de Dados",
    "section": "",
    "text": "Conteúdos\nQuando precisamos expôr resultados de forma objetiva e clara, devemos recorrer a recursos visuais. Uma boa visualização de dados se utiliza destes rercursos para chamar à atenção e a compreensão do público diante a análise que foi executada. Tabelas, gráficos, diagramas, etc, são exemplos de visulização. Desta forma, veremos que o Python nos oferece uma gama de opções para desenvolver tais recursos.\nO gráfico de linha é um tipo de gráfico que exibe informações com uma série de pontos de dados chamados de marcadores, ligados por segmentos de linha reta.\nFaremos um gráfico da quantidade de divórcios conscedidos em primeira instância o longo dos anos de 2009 a 2017 no Brasil. Para isto, criaremos um gráfico de linha com o intuito de demonstrar a confecção de uma série temporal.\nO gráfico de barras é uma ferramenta que possibilita a análise de dados observando o tamanho de barras verticais ou horizontais. Estas barras podem reprensentar frequências e valores de variáveis.\nIremos criar uma classe chamada de “Dado”, essa classe imita um dado. Para ser iniciada, devemos passar Dado (Número de faces no dado). Possui um método chamado de “rolar_dado” que simula o lançamento do dado.\nAqui iremos simular o lançamento de 2 dados com 5 faces e soma-las e também o lançamento de 1 dado com 10 faces. Iremos fazer 10000 lançamentos e comparar a frequência de resultados obtidos.\nIremos utilizar o método sns.barplot() para dizer ao python para guardar um gráfico de barras em memória. Se utilizarmos o comando duas vezes seguidas para diferentes conjuntos de dados os gráficos ficarão sobrepostos. Após isso, podemos utilizar plt.show() para mostrar os gráficos ao final da linha.\nGerando o gráfico\nPara o lançamento de 2 dados de 5 faces.\nGeraremos uma amostra aleatória de tamanho 100 de uma população normal padrão utilizando a biblioteca numpy, com o intuito de gerar dados para os gráficos.\nSimilar ao código anterior, o próximo gráfico recebe o argumento hist com o valor False isso fará com que o histograma seja omitido e apenas a cruva de densidade distribuição da nossa amostra apareça. O argumento rug também recebe um booleano, em caso de True adiciona rug plot ao nosso gráfico. Rug plot ou gráfico de tapete mostra a distribuição dos dados de forma unidimensional.\nSe quisermos colocar várias distribuições no mesmo conjunto de eixos.\nO gráfico de setores, também conhecido como gráfico de pizza, possui a mesma aplicação do gráfico de barras. Ele é geralmente utilizado para ilustrar quando há alta diferença entre frequências das variáveis estudadas. Quando não há essa diferença ou existem muitas divisões entre é preferível utilizar o gráfico de barras.\nPara gerar um gráfico de setores devemos primeiro contruir uma lista com as contagens de cada elemento e a outra lista com os rótulos desejados para cada contagem.\nAgora utilizaremos um banco de dados localizado na pasta datasets/ sobre o desempenho de alunos em testes de matemática e leitura e geraremos uma visualização para ele.\nBoxplot é uma ferramenta gráfica para representar a variação de dados observados de uma variável numérica por meio de quartis, amplitude dos dados e possíveis pontos discrepantes. Os chamados ‘bigodes’, linhas horizontais localizadas nas pontas das caixas representam o máximo e o mínimo dos valores observados não levando em consideração os outliers. Outliers são valores discrepantes observados na nossa amostra. A linha horizontal central se trata da mediana, ou seja, até ela se encontram 50% dos dados observados. Ela é cercada por outras duas linhas o primeiro e terceiro quartis, que correspondem a 25% e 75% dos valores observados.\nsns.boxplot é o metodo responsável por criar boxplots. Temos como argumentos os valores de x e y. Além disso, podemos colocar o argumento hue que recebe uma string com o nome de uma coluna com dados categórico, com o intuito de separar nossa observação nesses grupos. palette seleciona a paleta de cores, neste caso magenta e verde.\nO gráfico de dispersão utiliza duas variáveis quantitativas nos eixos x e y para desenhar pontos para cada observação da amostra.\nPara gerar um simples gráfico de dispersão podemos utilizar o método sns.scatterplot apenas passando as veriáveis de interesse que desejamos comparar.\nO método sns.regplot também recebe como argumentos as variáveis que desejamos estudar a correlação, sendo muito semelhante ao método que gera um gráfico de dispersão.\nsns.regplot(x=“math score”, y=“reading score”, data=data); sns.despine(offset=10, trim=True)\nAgora vejamos como é simples criar em uma punica imagem um gráfico de regressão que separa em nossa amostra em dois grupos, neste caso o gênero.\nUtilizando o método plt.subplots() gera um “quadro” para que alocar os nossos gráficos. Os argumentos nrows e ncols determinam a número de linhas e colunas do nosso painel, respectivamente. O argumento figsize recebe um array com a altura e largura dos quadros."
  },
  {
    "objectID": "VisualizacaoDeDados.html#matplotlib",
    "href": "VisualizacaoDeDados.html#matplotlib",
    "title": "5  Visualização de Dados",
    "section": "Matplotlib",
    "text": "Matplotlib\nO matplotlib é a principal biblioteca de visualização de dados no Python. Trata-se de uma biblioteca muito completa, sendo ideal para gerar qualquer tipo de gráfico. No entanto, as opções de personalização dos gráficos podem ser maçantes e complexas quando utilizamos apenas o matplotlib para gerar nossas visualizações, e por isso ferramentas como o seaborn facilitam a execução desta tarefa."
  },
  {
    "objectID": "VisualizacaoDeDados.html#seaborn",
    "href": "VisualizacaoDeDados.html#seaborn",
    "title": "5  Visualização de Dados",
    "section": "Seaborn",
    "text": "Seaborn\nA biblioteca seaborn simplifica e abstrai algumas configurações de temas que seriam mais complexas do matplotlib, gerando gráficos mais atrativos com códigos mais limpos e mais simples. Neste notebook, apenas nos prenderemos a utilizar ao Seaborn por sua praticidade."
  },
  {
    "objectID": "VisualizacaoDeDados.html#importação",
    "href": "VisualizacaoDeDados.html#importação",
    "title": "5  Visualização de Dados",
    "section": "Importação",
    "text": "Importação\nimport matplotlib.pyplot as plt # É a principal ferramenta capaz de gerar gráficos no python. import seaborn as sns # Baseado no matplotlib o seaborn é uma biblioteca que facilita a criacao de gráficos no # matplotlib. import numpy as np # Estaremos importando o numpy apenas para executar alguns exemplos. import pandas as pd # Neste notebook apenas utilizaremos para a leitura de csv."
  },
  {
    "objectID": "VisualizacaoDeDados.html#boxplot-simples",
    "href": "VisualizacaoDeDados.html#boxplot-simples",
    "title": "5  Visualização de Dados",
    "section": "Boxplot simples",
    "text": "Boxplot simples\nnp.random.seed(1337)\namostra_qui_quadrado = np.random.chisquare(10, 1000)\nsns.boxplot(y=amostra_qui_quadrado)\nsns.despine(trim=True)                                 # `sns.despine` controla a estetética do gráfico o argumetno trim = True\n                                                       # remove o contorno da caixa de gráfico\n\nplt.title('Boxplot simples\\n$X\\sim\\chi_{10}$')         # Veja que podemos utilizar Latex no título.\nplt.show()"
  },
  {
    "objectID": "VisualizacaoDeDados.html#boxplot-complexos",
    "href": "VisualizacaoDeDados.html#boxplot-complexos",
    "title": "5  Visualização de Dados",
    "section": "Boxplot complexos",
    "text": "Boxplot complexos\nsns.boxplot(x=\"race/ethnicity\",                                              # Eixo X receberá os grupos.\n            y=\"math score\",                                                  # Eixo Y receberá a variável quantitativa\n            hue=\"gender\",                                                    # Hue colore o gráfico de acordo com outra variável categórica\n                                                                             # neste caso o gênero\n            palette=[\"m\", \"g\"],                                              # Paleta de cores neste caos 'm', magenta e 'g' verde\n            order=['group A', 'group B', 'group C', 'group D', 'group E'],   # Trocando a ordem em que os grupos aparecem\n                                                                             # no eixo X.\n            data=data)                                                       # Dados\n\nsns.despine(offset=10, trim=True)"
  },
  {
    "objectID": "EstimativaPorIntervalos.html",
    "href": "EstimativaPorIntervalos.html",
    "title": "Estimativa por Intervalos",
    "section": "",
    "text": "Biblioteca statsmodels\nA biblioteca statsmodels é um módulo Python que fornece classes e funções para a estimativa de muitos modelos estatísticos diferentes, bem como para a realização de testes estatísticos e a exploração de dados.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Estimativa por Intervalos</span>"
    ]
  },
  {
    "objectID": "EstimativaPorIntervalos.html#importação",
    "href": "EstimativaPorIntervalos.html#importação",
    "title": "Estimativa por Intervalos",
    "section": "Importação",
    "text": "Importação\n\nimport statsmodels.api as sm\nimport scipy.stats as ss\nimport pandas as pd\nimport numpy as np",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Estimativa por Intervalos</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html",
    "href": "TesteDeHipotesesParte1.html",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "",
    "text": "Importação",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#exemplos",
    "href": "TesteDeHipotesesParte1.html#exemplos",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Exemplos",
    "text": "Exemplos\nExemplo 1: Uma revista X afirmou que o tempo de produção de parafusos de uma máquina da empresa Y é em média de 2 horas. Deseja-se saber se essa afirmação é verdadeira.\nHipótese Nula: \\(H_{0} : \\mu = 2\\)\nHipótese Alternativa: \\(H_{1} : \\mu\\neq  2\\)\nExemplo 2: Uma empresa afirma que seus funcionários da área de TI possuem idade média maior que 40 anos. Desaja-se saber se essa afirmação é verdadeira.\nHipótese Nula: \\(H_{0} : \\mu = 40\\)\nHipótese Alternativa: \\(H_{1} : \\mu &gt; 40\\)\nOBS: Vale citar que, são mais utilizadas as hipóteses nulas apenas representadas por igualdades. Porém como forma de interpretação, essa hipótese é associada ao inverso da hipótese alternativa. Tendo como exemplo caso anterior, temos a hipótese nula \\(H_{0} : \\mu = 40\\) que pode ser entendida também como \\(H_{0} : \\mu \\leq 40\\). Pois ao ser realizado um teste para verificar a veracidade da informação, busca-se evidências que a idade média é maior que 40. Caso não há evidências a favor, tem-se que a idade média pode ser menor ou igual a 40.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-a-média-populacional",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-a-média-populacional",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipótese para a Média Populacional",
    "text": "Teste de Hipótese para a Média Populacional\nSeja \\(X1, . . . , Xn\\) uma amostra aleatória de uma população normal com média μ e variância σ² desconhecidas. E suponha que queremos testar as seguintes hipóteses:\n\\(H_{0} : \\mu = \\mu_{0}\\)\nvs\n\\(H_{1} : \\mu &lt; ou &gt; ou \\neq \\mu_{0}\\),\nonde \\(\\mu_{0}\\) ∈ \\(\\mathbb{R}\\).\nSeja T a estatística do teste definida por:\nT = \\(\\frac{\\bar{X}-\\mu}{\\frac{S}{\\sqrt{n}}} \\sim t_{n-1}\\)\nonde \\(\\bar{X}\\) e \\(S\\) são a média amostral e a variância amostral, respectivamente.\nApós a definição das hipóteses e da estatística de teste, temos que o p-valor é calculado por:\n\nSe \\(H_{1}: \\mu \\neq \\mu_{0}\\): \\(p-valor = P (T &gt; T_{obs}\\mid H_{0})\\)\nSe \\(H_{1}: \\mu  &gt; \\mu_{0}\\) \\(p-valor = P (T &gt; T_{obs}\\mid H_{0})\\)\n\\(H_{1}: \\mu  &lt; \\mu_{0}\\) \\(p-valor = P (T &lt; T_{obs}\\mid H_{0})\\)\n\nonde\n\\(T_{obs} = \\frac{\\bar{X}-\\mu_{0}}{\\frac{S}{\\sqrt{n}}}\\)\nPara se aplicar o teste de média para uma população com variância desconhecida, utilizamos a função ttest_1samp da biblioteca scipy, cujo argumentos de entrada obrigatórios são:\n\na : a amostra observada.\npopmean : valor associado a \\(\\mu_{0}\\) nas hipóteses.\n\nNota-se que essa função não possui nenhum argumento de entrada que indique o tipo da hipótese alternativa (unilateral ou bilateral) que será utilizada. Logo, tem-se que essa função retorna apenas o valor do \\(T_{obs}\\) e o p-valor do teste bilateral. Dessa forma, só podem ser aplicados testes cuja hipótese nula seja \\(\\mu \\neq \\mu_{0}\\).\nComo na biblioteca statsmodels não há função para a utilização das hipóteses unilaterais, iremos também criar a função ttest_uni que retorna o valor de \\(T_{obs}\\) e o p-valor, e possui como argumentos de entrada:\n\namostra: amostra observada.\npopmean: valor associado a \\(\\mu_{0}\\) nas hipóteses.\nalternative: tipo da hipótese alternativa desejada: “larger” (unilateral à direita) ou “smaller” (unilateral à esquerda).\n\ndef ttest_uni(amostra, popmean, alternative):\n    n= len(amostra)\n    tobs = (np.mean(amostra)-popmean)/np.sqrt(np.var(amostra, ddof=1)/n)\n    if(alternative == \"smaller\"):\n        pvalor = ss.t.cdf(tobs,n-1)\n    if(alternative == \"larger\"):\n        pvalor = 1 - ss.t.cdf(tobs,n-1)\n    \n    print('(%.16f,%.16f)' % (tobs,pvalor))\nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a facilidade da aplicabilidade das funções e dos conceitos estatísticos já apresentados.\nPara isso será utilizado um banco de dados que representa uma amostra aleatória simples de 1470 funcionários da empresa IBM.\nbase=pd.read_csv('R-Employee-Attrition.csv')\nbase.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n0\n41\nYes\nTravel_Rarely\n1102\nSales\n1\n2\nLife Sciences\n1\n1\n...\n1\n80\n0\n8\n0\n1\n6\n4\n0\n5\n\n\n1\n49\nNo\nTravel_Frequently\n279\nResearch & Development\n8\n1\nLife Sciences\n1\n2\n...\n4\n80\n1\n10\n3\n3\n10\n7\n1\n7\n\n\n2\n37\nYes\nTravel_Rarely\n1373\nResearch & Development\n2\n2\nOther\n1\n4\n...\n2\n80\n0\n7\n3\n3\n0\n0\n0\n0\n\n\n3\n33\nNo\nTravel_Frequently\n1392\nResearch & Development\n3\n4\nLife Sciences\n1\n5\n...\n3\n80\n0\n8\n3\n3\n8\n7\n3\n0\n\n\n4\n27\nNo\nTravel_Rarely\n591\nResearch & Development\n2\n1\nMedical\n1\n7\n...\n4\n80\n1\n6\n3\n3\n2\n2\n2\n2\n\n\n\n\n\n\nExemplo 1:\nDado que a idade dos funcionários da empresa IBM que raramente viajam a trabalho segue uma distribuição normal com média e variância desconhecidas. Deseja-se testar se a média das idades dos funcionários que raramente viajam a trabalho pode ser considerada ou não igual a 37 anos, utilizando um nível de significância de 5%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\mu = 37\\)\nvs\n\\(H_{1} : \\mu\\neq 37\\)\nbase_rarely= base[base['BusinessTravel'] == \"Travel_Rarely\"] # Filtrar apenas os dados dos que raramente viajam a trabalho.\nbase_rarely.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n0\n41\nYes\nTravel_Rarely\n1102\nSales\n1\n2\nLife Sciences\n1\n1\n...\n1\n80\n0\n8\n0\n1\n6\n4\n0\n5\n\n\n2\n37\nYes\nTravel_Rarely\n1373\nResearch & Development\n2\n2\nOther\n1\n4\n...\n2\n80\n0\n7\n3\n3\n0\n0\n0\n0\n\n\n4\n27\nNo\nTravel_Rarely\n591\nResearch & Development\n2\n1\nMedical\n1\n7\n...\n4\n80\n1\n6\n3\n3\n2\n2\n2\n2\n\n\n6\n59\nNo\nTravel_Rarely\n1324\nResearch & Development\n3\n3\nMedical\n1\n10\n...\n1\n80\n3\n12\n3\n2\n1\n0\n0\n0\n\n\n7\n30\nNo\nTravel_Rarely\n1358\nResearch & Development\n24\n1\nLife Sciences\n1\n11\n...\n2\n80\n1\n1\n2\n3\n1\n0\n0\n0\n\n\n\n\n\nss.ttest_1samp(base_rarely['Age'],popmean = 37)\nTtest_1sampResult(statistic=0.3183482529054914, pvalue=0.7502845793964478)\nComo p-valor = 0.75 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, há evidências que a média das idades dos funcionários que raramente viajam a trabalho é igual a 37 anos.\n\n\nExemplo 2\nDado que a idade dos funcionários da empresa IBM que frequentemente viajam a trabalho segue uma distribuição normal com média e variância desconhecidas. Deseja-se testar se a média das idades dos funcionários que frequentemente viajam a trabalho pode ser considerada menor que 39 anos, utilizando um nível de significância de 1%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\mu = 39\\)\nvs\n\\(H_{1} : \\mu &lt; 39\\)\nbase_freq= base[base['BusinessTravel'] == \"Travel_Frequently\"] # Filtrar apenas os dados dos que frequentemente viajam a trabalho.\nbase_freq.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n1\n49\nNo\nTravel_Frequently\n279\nResearch & Development\n8\n1\nLife Sciences\n1\n2\n...\n4\n80\n1\n10\n3\n3\n10\n7\n1\n7\n\n\n3\n33\nNo\nTravel_Frequently\n1392\nResearch & Development\n3\n4\nLife Sciences\n1\n5\n...\n3\n80\n0\n8\n3\n3\n8\n7\n3\n0\n\n\n5\n32\nNo\nTravel_Frequently\n1005\nResearch & Development\n2\n2\nLife Sciences\n1\n8\n...\n3\n80\n0\n8\n2\n2\n7\n7\n3\n6\n\n\n8\n38\nNo\nTravel_Frequently\n216\nResearch & Development\n23\n3\nLife Sciences\n1\n12\n...\n2\n80\n0\n10\n2\n3\n9\n7\n1\n8\n\n\n26\n32\nYes\nTravel_Frequently\n1125\nResearch & Development\n16\n1\nLife Sciences\n1\n33\n...\n2\n80\n0\n10\n5\n3\n10\n2\n6\n7\n\n\n\n\n\nttest_uni(amostra = base_freq['Age'], popmean = 39, alternative = \"smaller\")\n\n\n\n\n\n\n(-4.9557346279446639,0.0000006294162639)\n\n\n\nComo p-valor = 0.0000006 é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, há evidências que a média das idades dos funcionários que frequentemente viajam a trabalho é menor do que a 39 anos.\n\n\nExemplo 3\nDado que a idade dos funcionários da empresa IBM do departamento de vendas segue uma distribuição normal com média e variância desconhecidas. Deseja-se testar se a média das idades dos funcionários do departamento de vendas pode ser considerada maior do que 40 anos, utilizando um nível de significância de 10%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\mu = 40\\)\nvs\n\\(H_{1} : \\mu&gt; 40\\)\nbase_sales= base[base['Department'] == \"Sales\"] # Filtrar apenas os dados dos funcinários do departamento de vendas.\nbase_sales.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n0\n41\nYes\nTravel_Rarely\n1102\nSales\n1\n2\nLife Sciences\n1\n1\n...\n1\n80\n0\n8\n0\n1\n6\n4\n0\n5\n\n\n18\n53\nNo\nTravel_Rarely\n1219\nSales\n2\n4\nLife Sciences\n1\n23\n...\n3\n80\n0\n31\n3\n3\n25\n8\n3\n7\n\n\n21\n36\nYes\nTravel_Rarely\n1218\nSales\n9\n4\nLife Sciences\n1\n27\n...\n2\n80\n0\n10\n4\n3\n5\n3\n0\n3\n\n\n27\n42\nNo\nTravel_Rarely\n691\nSales\n8\n4\nMarketing\n1\n35\n...\n4\n80\n1\n10\n2\n3\n9\n7\n4\n2\n\n\n29\n46\nNo\nTravel_Rarely\n705\nSales\n2\n4\nMarketing\n1\n38\n...\n4\n80\n0\n22\n2\n2\n2\n2\n2\n1\n\n\n\n\n\nttest_uni(amostra = base_sales['Age'],popmean = 40, alternative = \"larger\")\n\n\n\n\n\n\n(-8.0835777128154724,0.9999999999999970)\n\n\n\nComo o p-valor é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, não há evidências que a idade média dos funcionários do departamento de vendas seja maior que 40 anos.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-a-proporção",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-a-proporção",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipóteses para a Proporção",
    "text": "Teste de Hipóteses para a Proporção\nDe posse de uma grande amostra aleatória simples \\(X1, X2,…,Xn\\) extraída de uma população \\(X ∼ Ber(p)\\), nosso interesse está em testar a hipótese nula\n\\(H_{0} : p = p_{0}\\)\na um nível de significância α, onde \\(p_0 \\in (0,1)\\). E \\(p\\) se trata da proporção de elementos de uma população que possuem determinada característica de interesse para o experimento. Dependendo do conhecimento sobre o problema, a hipótese alternativa pode tomar uma das três formas:\n\\(H_{1} : p &lt;  ou  &gt;  ou  \\neq p_{0}\\)\nEm qualquer dos casos, a estatística de teste baseia-se na proporção amostral; para grandes amostras, sabemos que\n\\(Z = \\frac{\\hat{p}-p}{\\sqrt{\\frac{p\\left ( 1-p \\right )}{n}}} \\sim N(0,1)\\)\nApós as definições das hipóteses e da estatística de teste, temos que o p-valor é calculado por:\n\nSe \\(H_{1}: p \\neq p_{0}\\)\n\np-valor = P(Z \\geq \\left   Z_{obs} \\right  \\mid H_{0})\n\nSe \\(H_{1}: p &gt; p_{0}\\) \\(p-valor = P (Z &gt; Z_{obs}\\mid H_{0})\\)\nSe \\(H_{1}: p &lt; p_{0}\\) \\(p-valor = P (Z &lt; Z_{obs}\\mid H_{0})\\)\n\nonde\n\\(Z_{obs} = \\frac{\\hat{p}-p_{0}}{\\sqrt{\\frac{p_{0}\\left ( 1 - p_{0} \\right )}{n}}}\\)\nPara se aplicar o teste para proporção populacional, utilizamos a função ztest da biblioteca statsmodels que retorna o \\(Z_{obs}\\) e o p-valor, e possui como argumentos de entrada obrigatórios:\n\nx1: a amostra observada.\nvalue: valor associado a \\(p_{0}\\)\nalternative: tipo da hipótese alternativa desejada: “two-sided” (bilateral) , “larger” (unilateral à direita) ou “smaller” (unilateral à esquerda).\n\nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a aplicabilidade das funções e dos conceitos estatísticos já apresentados.\nUtilizaremos o banco de dados dos funcionários da empresa IBM já apresentado anteriormente.\n\nExemplo 1:\nDeseja-se averiguar se é corretar afirmar que 25% dos funcionários do departamento de vendas do IBM passaram por algum problema na empresa, utilizando um nível de significância de 5%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : p = 0.25\\)\nvs\n\\(H_{1} : p\\neq 0.25\\)\nTem-se essa informação através da variável Attrition do banco de dados.\nbase_sales['Attrition'] = base_sales['Attrition'].map({'Yes' : 1, 'No' : 0}) # transformando a variável Risk para valores numéricos\nbase_sales.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n0\n41\n1\nTravel_Rarely\n1102\nSales\n1\n2\nLife Sciences\n1\n1\n...\n1\n80\n0\n8\n0\n1\n6\n4\n0\n5\n\n\n18\n53\n0\nTravel_Rarely\n1219\nSales\n2\n4\nLife Sciences\n1\n23\n...\n3\n80\n0\n31\n3\n3\n25\n8\n3\n7\n\n\n21\n36\n1\nTravel_Rarely\n1218\nSales\n9\n4\nLife Sciences\n1\n27\n...\n2\n80\n0\n10\n4\n3\n5\n3\n0\n3\n\n\n27\n42\n0\nTravel_Rarely\n691\nSales\n8\n4\nMarketing\n1\n35\n...\n4\n80\n1\n10\n2\n3\n9\n7\n4\n2\n\n\n29\n46\n0\nTravel_Rarely\n705\nSales\n2\n4\nMarketing\n1\n38\n...\n4\n80\n0\n22\n2\n2\n2\n2\n2\n1\n\n\n\n\n\nztest(x1 = base_sales['Attrition'], value = 0.25, alternative = \"two-sided\")\n\n\n\n\n\n\n(-2.279392275404384, 0.0226437570988434)\n\n\n\nComo p-valor = 0.02 é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, há evidências que a proporção de funcionários que passaram por problemas é diferente de 25%.\n\n\nExemplo 2:\nDeseja-se averiguar se é corretar afirmar que menos de 30% dos funcionários do departamento de pesquisa do IBM passaram por algum problema na empresa, utilizando um nível de significância de 10%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : p = 0.3\\)\nvs\n\\(H_{1} : p&lt; 0.3\\)\nbase_pesq= base[base['Department'] == \"Research & Development\"] # Filtrar apenas os dados dos funcinários do departamento de vendas.\nbase_pesq['Attrition'] = base_pesq['Attrition'].map({'Yes' : 1, 'No' : 0})\nbase_pesq.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n1\n49\n0\nTravel_Frequently\n279\nResearch & Development\n8\n1\nLife Sciences\n1\n2\n...\n4\n80\n1\n10\n3\n3\n10\n7\n1\n7\n\n\n2\n37\n1\nTravel_Rarely\n1373\nResearch & Development\n2\n2\nOther\n1\n4\n...\n2\n80\n0\n7\n3\n3\n0\n0\n0\n0\n\n\n3\n33\n0\nTravel_Frequently\n1392\nResearch & Development\n3\n4\nLife Sciences\n1\n5\n...\n3\n80\n0\n8\n3\n3\n8\n7\n3\n0\n\n\n4\n27\n0\nTravel_Rarely\n591\nResearch & Development\n2\n1\nMedical\n1\n7\n...\n4\n80\n1\n6\n3\n3\n2\n2\n2\n2\n\n\n5\n32\n0\nTravel_Frequently\n1005\nResearch & Development\n2\n2\nLife Sciences\n1\n8\n...\n3\n80\n0\n8\n2\n2\n7\n7\n3\n6\n\n\n\n\n\nztest(x1 = base_pesq['Attrition'], value = 0.30, alternative = \"smaller\")\n\n\n\n\n\n\n(-14.499935934146963, 6.063151045772378e-48)\n\n\n\nComo p-valor é menor do que o nível de significância proposto, rejeitamos \\(H_0\\), ou seja, há evidências que a proporção de funcionários do departamento de vendas que passaram por algum problema é menos de 30%.\n\n\nExemplo 3:\nDeseja-se averiguar se é corretar afirmar que mais de 60% dos funcionários do IBM que frequentemente viajam a trabalho passaram por algum problema na empresa, utilizando um nível de significância de 1%.\n\\(H_{0} : p = 0.6\\)\nvs\n\\(H_{1} : p &gt; 0.6\\)\nbase_freq['Attrition'] = base_freq['Attrition'].map({'Yes' : 1, 'No' : 0})\nbase_freq.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n1\n49\n0\nTravel_Frequently\n279\nResearch & Development\n8\n1\nLife Sciences\n1\n2\n...\n4\n80\n1\n10\n3\n3\n10\n7\n1\n7\n\n\n3\n33\n0\nTravel_Frequently\n1392\nResearch & Development\n3\n4\nLife Sciences\n1\n5\n...\n3\n80\n0\n8\n3\n3\n8\n7\n3\n0\n\n\n5\n32\n0\nTravel_Frequently\n1005\nResearch & Development\n2\n2\nLife Sciences\n1\n8\n...\n3\n80\n0\n8\n2\n2\n7\n7\n3\n6\n\n\n8\n38\n0\nTravel_Frequently\n216\nResearch & Development\n23\n3\nLife Sciences\n1\n12\n...\n2\n80\n0\n10\n2\n3\n9\n7\n1\n8\n\n\n26\n32\n1\nTravel_Frequently\n1125\nResearch & Development\n16\n1\nLife Sciences\n1\n33\n...\n2\n80\n0\n10\n5\n3\n10\n2\n6\n7\n\n\n\n\n\nztest(x1 = base_freq['Attrition'], value = 0.6, alternative = \"larger\")\n\n\n\n\n\n\n(-13.47921476827307, 1.0)\n\n\n\nComo p-valor = 1 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, não há evidências de que mais de 60% dos funcionários que frequentemente viajam a trabalho tenham tido alguma complicação na empresa.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-a-variância",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-a-variância",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipóteses para a Variância",
    "text": "Teste de Hipóteses para a Variância\nSeja \\(X1, X2,…,Xn\\) uma amostra aleatória de uma população com distribuição normal, com média μ e variância σ² desconhecidas.\nE suponha que estamos interessados em testar as hipóteses\n\\(H_{o}: \\sigma^{2} = \\sigma^{2}_{0}\\)\nvs\n\\(H_{1}: \\sigma^{2} &lt; ou  &gt; ou \\neq \\sigma^{2}_{0}\\),\nonde \\(σ_{0}^{2}\\) &gt; 0.\nEm qualquer dos casos, a estatística de teste Q é dada por:\n\\(Q = \\frac{(n-1)S^{2}}{\\sigma^{2}}\\sim \\chi^{2}_{(n-1)}\\)\nApós as definições das hipóteses e da estatística de teste, temos que o p-valor é calculado por:\n\nSe \\(H_{1}: \\sigma^{2} \\neq \\sigma^{2}_{0}\\),\n\nMissing or unrecognized delimiter for \\left\n\nSe \\(H_{1}: \\sigma^{2} &gt; \\sigma^{2}_{0}\\), \\(p-valor = P (Q &gt; Q_{obs}\\mid H_{0})\\)\nSe \\(H_{1}: \\sigma^{2} &lt; \\sigma^{2}_{0}\\) \\(p-valor = P (Q &lt; Q_{obs}\\mid H_{0})\\)\n\nonde\n\\(Q_{obs} = \\frac{(n-1)S^{2}}{\\sigma_{0}^{2}}\\)\nComo não há funções pertencentes às bibliotecas statsmodels e scipy que realizam o teste para a variância, criamos uma função própria chamada test_var que retorna o \\(Q_{obs}\\) e o p-valor, e recebe como argumentos de entrada:\n\namostra: amostra observada\nsigma2: valor referente a \\(\\sigma^{2}_{0}\\)\nalternative: tipo da hipótese alternativa desejada: “two-sided” (bilateral) , “larger” (unilateral à direita) ou “smaller” (unilateral à esquerda).\n\ndef test_var (amostra, sigma2, alternative= \"two.sided\"):\n    n=len(amostra)\n    qobs= (n-1)*np.var(amostra, ddof=1)/sigma2\n    \n    if(alternative == \"smaller\"):\n        pvalor = ss.chi2.cdf(qobs,n-1)\n    if(alternative == \"larger\"):\n        pvalor = 1 - ss.chi2.cdf(qobs,n-1)\n    if(alternative == \"two.sided\"):\n        pvalor = 2*np.minimum(1 - ss.chi2.cdf(qobs,n-1),ss.chi2.cdf(qobs,n-1))\n        \n    print('(%.16f,%.16f)' % (qobs,pvalor))\nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a facilidade da aplicabilidade das funções e dos conceitos estatísticos já apresentados. Utilizaremos o banco de dados dos funcionários da empresa IBM.\n\nExemplo 1:\nUm dos diretores da empresa IBM afirmou que a variabilidade da idade dentre seus funcionários é de 76 anos². Dado que a idade dos funcionários segue uma distribuição normal com média e variância desconhecidas, deseja-se averiguar a veracidade da afirmação, utilizando um nível de significância de 1%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\sigma^{2} = 76\\)\nvs\n\\(H_{1} : \\sigma^{2} \\neq 76\\)\nNesse caso não é preciso realizar nenhum processo de filtragem, ou seja, utilzaremos a base original.\ntest_var(amostra = base['Age'], sigma2 = 76, alternative = \"two.sided\")\n\n\n\n\n\n\n(1613.0982456140357044,0.0096419873719233)\n\n\n\nComo p-valor = 0.009 é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, temos evidências de que a variabilidade das idades dos funcionários é diferente de 76. Portanto a afirmação é considerada equivocada.\n\n\nExemplo 2:\nUm jornal local noticiou que a variabilidade dos anos de trabalho dos funcionários da empresa IBM é inferior a 60 anos². Dado que os anos de trabalho dos funcionários da empresa IBM segue uma distribuição normal com média e variância desconhecidas, deseja-se averiguar a veracidade da afirmação, utilizando um nível de significância de 5%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\sigma^{2} = 60\\)\nvs\n\\(H_{1} : \\sigma^{2} &lt; 60\\)\nNesse caso, também não é preciso realizar nenhum processo de filtragem, ou seja, utilizaremos a base original.\ntest_var(base['TotalWorkingYears'],60,\"smaller\")\n\n\n\n\n\n\n(1482.2347959183696275,0.6009205627661879)\n\n\n\nComo p-valor = 0.6 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, não há evidências que a variabilidade dos anos de trabalho dos funcionários seja inferior a 60. Portanto, considera-se que a informação noticiada é incorreta.\n\n\nExemplo 3:\nUm dos funcionários da empresa afirmou que a variabilidade dos anos de trabalho dos funcionários da empresa IBM casados é superior a 30 anos². Dado que os anos de trabalho dos funcionários casados da empresa IBM segue uma distribuição normal com média e variância desconhecidas, deseja-se averiguar a veracidade da afirmação, utilizando um nível de significância de 10%.\nAtravés desse problema temos as hipóteses:\n\\(H_{0} : \\sigma^{2} = 30\\)\nvs\n\\(H_{1} : \\sigma^{2} &gt; 30\\)\nPodemos achar essa informação através da variável MaritalStatus presente no banco de dados.\nbase_casados = base[base['MaritalStatus'] == \"Married\"] \nbase_casados.head()\n\n\n\n\n\n\n\nAge\nAttrition\nBusinessTravel\nDailyRate\nDepartment\nDistanceFromHome\nEducation\nEducationField\nEmployeeCount\nEmployeeNumber\n...\nRelationshipSatisfaction\nStandardHours\nStockOptionLevel\nTotalWorkingYears\nTrainingTimesLastYear\nWorkLifeBalance\nYearsAtCompany\nYearsInCurrentRole\nYearsSinceLastPromotion\nYearsWithCurrManager\n\n\n\n\n1\n49\nNo\nTravel_Frequently\n279\nResearch & Development\n8\n1\nLife Sciences\n1\n2\n...\n4\n80\n1\n10\n3\n3\n10\n7\n1\n7\n\n\n3\n33\nNo\nTravel_Frequently\n1392\nResearch & Development\n3\n4\nLife Sciences\n1\n5\n...\n3\n80\n0\n8\n3\n3\n8\n7\n3\n0\n\n\n4\n27\nNo\nTravel_Rarely\n591\nResearch & Development\n2\n1\nMedical\n1\n7\n...\n4\n80\n1\n6\n3\n3\n2\n2\n2\n2\n\n\n6\n59\nNo\nTravel_Rarely\n1324\nResearch & Development\n3\n3\nMedical\n1\n10\n...\n1\n80\n3\n12\n3\n2\n1\n0\n0\n0\n\n\n9\n36\nNo\nTravel_Rarely\n1299\nResearch & Development\n27\n3\nMedical\n1\n13\n...\n2\n80\n2\n17\n3\n2\n7\n7\n7\n7\n\n\n\n\n\ntest_var(amostra = base_casados['TotalWorkingYears'], sigma2 = 50, alternative = \"larger\")\n\n\n\n\n\n\n(834.6771471025249411,0.0000173254449680)\n\n\n\nComo p-valor = 0.00001 é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja há evidências que a variabilidade dos anos trabalhados entre os casados é superior a 30.Portanto a afirmação realizada é dada como verdadeira.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-comparação-de-duas-proporções",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipóteses-para-comparação-de-duas-proporções",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipóteses para Comparação de Duas Proporções",
    "text": "Teste de Hipóteses para Comparação de Duas Proporções\nSejam \\({X_{1} \\sim N(\\mu_{1}, \\sigma^2_{1})}\\) e \\({X_{2} \\sim N(µ_{2}, σ^2_{2})}\\) duas amostras independentes de tamanho \\({n_{1}}\\) e \\({n_{2}}\\), respectivamente, e \\({ \\hat{p_{1}} }\\) e \\({ \\hat{p_{2}} }\\) estimadores de \\({p_{1}}\\) e \\({p_{2}}\\), proporção de ocorrência de um certo evento. Então, aproximadamente, \\({\\hat{p_{1}} \\sim N\\left ( p_{1}, \\frac{p_{1}(1 - p_{1})}{n_{1}} \\right )}\\) e \\({\\hat{p_{2}} \\sim N\\left ( p_{2}, \\frac{p_{2}(1 - p_{2})}{n_{2}} \\right )}\\) implicando \\({\\hat{p_{1}} - \\hat{p_{2}} \\sim N\\left ( p_{1} - p_{2}, \\frac{p_{1}(1 - p_{1})}{n_{1}}+ \\frac{p_{2}(1 - p_{2})}{n_{2}} \\right )}\\). Portanto:\n\\(Z = \\frac{(\\hat{p_{1}} - \\hat{p_{2}}) - (p_{1} - p_{2})}{\\sqrt{\\frac{\\hat{p_{1}}(1 - \\hat{p_{1}})}{n_{1}} + \\frac{\\hat{p_{2}}(1 - \\hat{p_{2}})}{n_{2}}}} \\sim N(0, 1)\\)\nPara realizar o teste da comparação de duas proporções, existem 3 formas de propor as hipóteses nula e alternativa:\n\\(H_{0}: p_{1} - p_{2} = p_{0} \\ \\ \\times \\ \\ H_{1}: p_{1} - p_{2} \\neq p_{0}\\)\nou\n\\(H_{0}: p_{1} - p_{2} = p_{0} \\ \\ \\times \\ \\ H_{1}: p_{1} - p_{2} &gt; p_{0}\\)\nou\n\\(H_{0}: p_{1} - p_{2} = p_{0} \\ \\ \\times \\ \\ H_{1}: p_{1} - p_{2} &lt; p_{0}\\)\nonde \\(p_0 \\in (0,1)\\).\nAtravés da estatística de teste e a definição das hipóteses, para a tomada de decisão é preciso calcular o p-valor, cujas fórmulas são dadas por:\n\nSe \\(H_{1} : p_{X} - p_{Y}\\neq p_{0}\\), \\(p-valor = P(|Z| \\geq \\left | Z_{obs} \\right |\\mid H_{0})\\)\nSe \\(H_{1} : p_{X} - p_{Y} &gt; p_{0}\\), \\(p-valor = P(Z &gt; Z_{obs}\\mid H_{0} )\\)\nSe \\(H_{1} : p_{X} - p_{Y} &lt; p_{0}\\), \\(p-valor = P(Z &lt; Z_{obs}\\mid H_{0} )\\)\n\nonde\n\\(Z_{obs} = \\frac{(\\hat{p}{1} - \\hat{p}{2}) - p_{0}}{\\sqrt{\\frac{\\hat{p}{1}(1 - \\hat{p}{1})}{n_{1}} + \\frac{\\hat{p}{2}(1 - \\hat{p}{2})}{n_{2}}}}\\)\nPara realizar esses cálculos no Python, utilizaremos a função ztest() da biblioteca statsmodels, já apresentado anteriormente, com os seguintes argumentos de entrada:\n\nx1: a amostra observada.\nx2: a segunda amostra observada.\nvalue: valor associado a \\(p_{0}\\)\nalternative: tipo da hipótese alternativa desejada: “two-sided” (bilateral) , “larger” (unilateral à direita) ou “smaller” (unilateral à esquerda).\n\nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a aplicabilidade das funções e dos conceitos estatísticos já apresentados. Utilizaremos um banco de dados que representa uma amostra aleatória simples de 562 filmes lançados no cinema no período de 2007 a 2011, com informações como gênero, orçamento e críticas presentes no site Rotten Tomatoes.\ndf = pd.read_csv('Movie-Ratings.csv')\ndf.head()\n\n\n\n\n\n\n\nFilm\nGenre\nRotten Tomatoes Ratings %\nAudience Ratings %\nBudget (million $)\nYear of release\n\n\n\n\n0\n(500) Days of Summer\nComedy\n87\n81\n8\n2009\n\n\n1\n10,000 B.C.\nAdventure\n9\n44\n105\n2008\n\n\n2\n12 Rounds\nAction\n30\n52\n20\n2009\n\n\n3\n127 Hours\nAdventure\n93\n84\n18\n2010\n\n\n4\n17 Again\nComedy\n55\n70\n20\n2009\n\n\n\n\n\n\nExemplo 1\nDeseja-se avaliar se no período de 2007 a 2011, a proporção de filmes de Comédia lançados no cinema foi igual a proporção de filmes de Aventura, utilizando um nível de significância de 5%.\nAs hipóteses serão as seguintes:\n\\(H_{0} : p_{X} - p_{Y}  = 0\\)\nvs\n\\(H_{1} : p_{X} - p_{Y}\\neq 0\\)\nOnde X ão filmes do gênero Comédia e Y, os filmes do gênero Aventura.\ndf['Genre_Comedy'] = np.where(df.Genre == \"Comedy\", 1, 0)\ndf['Genre_Adventure'] = np.where(df.Genre == \"Adventure\", 1, 0)\ndf.head()\n\n\n\n\n\n\n\nFilm\nGenre\nRotten Tomatoes Ratings %\nAudience Ratings %\nBudget (million $)\nYear of release\nGenre_Comedy\nGenre_Adventure\n\n\n\n\n0\n(500) Days of Summer\nComedy\n87\n81\n8\n2009\n1\n0\n\n\n1\n10,000 B.C.\nAdventure\n9\n44\n105\n2008\n0\n1\n\n\n2\n12 Rounds\nAction\n30\n52\n20\n2009\n0\n0\n\n\n3\n127 Hours\nAdventure\n93\n84\n18\n2010\n0\n1\n\n\n4\n17 Again\nComedy\n55\n70\n20\n2009\n1\n0\n\n\n\n\n\nztest(x1=df.Genre_Comedy, x2= df.Genre_Adventure, value = 0, alternative = 'two-sided')\n\n\n\n\n\n\n(11.789438693301005, 4.42480180658489e-32)\n\n\n\nComo o p-valor é menor que o nível de significância proposto, rejeitamos \\(H_0\\), ou seja, há evidências que as proporções de filmes de Comédia e de Aventura lançados no período de 2007 a 2011 nos cinema sejam diferentes.\n\n\nExemplo 2\nBaseado no resultado do exemplo anterior, sabe-se que as proporções de filmes de comédia e aventura em 2007-2011 são consideradas diferentes. Então, através disso, deseja-se avaliar se a proporção de filmes de Comédia é maior que a proporção de filmes de Aventura lançados nos cinemas em 2007-2011, utilizando um nível de significância de 1%.\nAs hipóteses serão as seguintes:\n\\(H_{0} : p_{X} - p_{Y}  = 0\\)\nvs\n\\(H_{1} : p_{X} - p_{Y} &gt; 0\\) \\(\\Rightarrow\\) \\(H_{1} : p_{X} &gt; p_{Y}\\)\nOnde X são filmes do gênero Comédia e Y, os filmes do gênero Aventura.\nztest(x1=df.Genre_Comedy, x2=df.Genre_Adventure, value = 0, alternative = 'larger')\n\n\n\n\n\n\n(11.789438693301005, 2.212400903292445e-32)\n\n\n\nComo p-valor é menor que o nível de significância proposto, rejeitamos \\(H_0\\), ou seja, há evidências que foram lançados mais filmes do gênero Comédia do que filmes do gênero Aventura nos cinemas no período de 2007 a 2011.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-razão-das-variâncias",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-razão-das-variâncias",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipótese para Razão das Variâncias",
    "text": "Teste de Hipótese para Razão das Variâncias\nSejam \\({X_1 \\sim N(µ_{1}, σ^2{1})}\\) e \\({X_2 \\sim N(µ{2}, σ^2{2})}\\) duas amostras independentes de tamanho \\({n{1}}{n_{2}}\\) e \\({S^2{1}}{S^2{2}}\\) suas variâncias amostrais. Então,\n\\(F = \\frac{\\frac{S^{2}{1}}{S^{2}{2}}}{\\frac{\\sigma^{2}{1}}{\\sigma ^{2}{2}}} \\sim F_{n_{1} - 1, n_{2} - 1}\\)\nPara realizar o teste para razão de duas variâncias, existem 3 formas de propor as hipóteses nula e alternativa:\n\n\\(H_{0}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} = \\sigma^{2}_{0} \\ \\ \\times \\ \\ H_{1}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} \\neq \\sigma^{2}_{0}\\)\n\\(H_{0}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} = \\sigma^{2}_{0} \\ \\ \\times \\ \\ H_{1}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} &lt; \\sigma^{2}_{0}\\)\n\\(H_{0}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} = \\sigma^{2}_{0} \\ \\ \\times \\ \\ H_{1}: \\frac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}} &gt; \\sigma^{2}_{0}\\)\n\nAtravés da estatística de teste e a definição das hipóteses, para a tomada de decisão é preciso calcular o p-valor, cujas fórmulas são dadas por:\n\nSe $H_{1} : \\frac{\\sigma^2{X}}{\\sigma^2{Y}}\\neq \\sigma^2{0}p-valor = 2\\times min\\left { P\\left ( F \\geq F{obs} \\mid H_{0}\\right ), P\\left ( F \\leq F_{obs} \\mid H_{0}\\right ) \\right }$\nSe \\(H_{1} : \\frac{\\sigma^2{X}}{\\sigma^2{Y}}&lt; \\sigma^2{0}p-valor = P\\left ( F &lt; F{obs}\\mid H_{0} \\right )\\)\nSe \\(H_{1} : \\frac{\\sigma^2{X}}{\\sigma^2{Y}}&gt; \\sigma^2{0}p-valor = P\\left ( F &gt; F{obs} \\mid H_{0}\\right )\\)\n\nonde\n\\(F_{obs} = \\frac{\\frac{S^{2}{1}}{S^{2}{2}}}{\\frac{\\sigma^{2}{1}}{\\sigma ^{2}{2}}}\\)\nInfelizmente, assim como no caso de uma população, o Python não possui função para avaliar a razão das variâncias. Por isso, construímos a nossa própria função, cujos argumentos de entrada são:\n\nx1: primeira amostra;\nx2: segunda amostra;\nvalue: valor de \\({\\sigma^{2}_{0}}\\);\nalternative: ‘two-sided’ (default): H1: razão das variâncias é diferente que value; ‘larger’: H1: razão das variâncias é maior que value; ‘smaller’: H1: razão das variâncias é menor que value.\n\nEssa função retorna a estatística de teste F e o p-valor calculado.\n# razão das variâncias\n\ndef rvar_test(x1, x2, value, alternative):\n    stattest = (np.var(x1)/np.var(x2))/value\n    \n    if alternative == 'smaller':\n        pvalor = ss.f.cdf(stattest, len(x1) - 1, len(x2) - 1)\n    elif alternative == 'larger':\n        pvalor = 1 - ss.f.cdf(stattest, len(x1) - 1, len(x2) - 1)\n    elif alternative == 'two-sided':\n        pvalor = 2*ss.f.cdf(stattest, len(x1) - 1, len(x2) - 1)\n        if pvalor &gt;= 1:\n            pvalor = 1\n        \n    print('(%.16f,%.16f)' % (stattest,pvalor)) \nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a facilidade da aplicabilidade da função e dos conceitos estatísticos já apresentados. Utilizaremos o banco de dados de avaliações de filmes.\n\nExemplo\nDado que os orçamentos dos filmes de Ação e Aventura seguem distribuições normais com médias e variâncias desconhecidas. Deseja-se avaliar, ao nível de significância de 5%, se a razão das variâncias dos orçamentos dos filmes de Ação e Aventura é igual a 1. Ou seja, verificar se as variâncias são iguais.\nAs hipótetes serão as seguintes:\n\\(H_{0} : \\frac{\\sigma^2{X}}{\\sigma^2{Y}} = 1\\)\nvs\n\\(H_{1} : \\frac{\\sigma^2{X}}{\\sigma^2{Y}}\\neq 1\\)\nOnde X são os orçamentos dos filmes de Ação e Y, os orçamentos dos filmes de Aventura.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-comparação-de-médias-para-duas-populações-independentes",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-comparação-de-médias-para-duas-populações-independentes",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipótese para Comparação de Médias para Duas Populações Independentes",
    "text": "Teste de Hipótese para Comparação de Médias para Duas Populações Independentes\nSejam \\({X \\sim N(µ_{X}, σ^2{X})}\\) e \\({Y \\sim N(µ{Y}, σ^2_{Y})}\\) duas amostras independentes com variâncias desconhecidas. Se, ao relizarmos o teste da razão das variâncias, constatarmos que as variâncias são iguais, teremos o seguinte caso:\n\\(T = \\frac{ (\\bar{X} - \\bar{Y}) - \\mu }{ \\sqrt{S^2{comb} \\left ( \\frac{1}{n{X}} + \\frac{1}{n_{Y}} \\right ) } } \\sim t_{n_{X} + n_{Y} - 2}\\)\nOnde,\n\\(S^{2}{comb} = \\frac{(n{X} - 1)S^2{X} + (n{Y} - 1)S^2{Y}}{n{X} + n_{Y} - 2}\\)\nSe, ao relizarmos o teste da razão das variâncias, constatarmos que as variâncias são diferentes, teremos o seguinte caso:\n\\(T = \\frac{ (\\bar{X} - \\bar{Y}) - \\mu }{ \\sqrt{ \\frac{S^2{X}}{n{X}} + \\frac{S^2{Y}}{n{Y}} } } \\sim t_{v}\\)\nOnde,\n\\(v = \\frac{ \\left ( \\frac{s^2{X}}{n{X}} + \\frac{s^2{Y}}{n{Y}} \\right )^2 }{ \\frac{1}{n_{X} - 1}\\left ( \\frac{s^2{X}}{n{X}} \\right )^2 + \\frac{1}{n_{Y} - 1}\\left ( \\frac{s^2{Y}}{n{Y}} \\right )^2 }\\)\nPara realizar o teste da comparação de duas médias, existem 3 formas de propor as hipóteses nula e alternativa:\n\n\\(H_{0}: \\mu_{X} - \\mu_{Y} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{X} - \\mu_{Y} \\neq \\mu_{0}\\)\n\\(H_{0}: \\mu_{1} - \\mu_{2} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{1} - \\mu_{2} &gt; \\mu_{0}\\)\n\\(H_{0}: \\mu_{1} - \\mu_{2} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{1} - \\mu_{2} &lt; \\mu_{0}\\)\n\nDada as estatísticas de teste e a definição das hipóteses, é preciso calcular o p-valor para a tomada de decisão, cujas fórmulas são dadas por:\n\nSe \\(H_{1}: \\mu_{X} - \\mu_{Y} \\neq \\mu_{0}\\), $p-valor = P\\left (    T   &gt; \\left T_{obs} \\right  \\mid H_{0} \\right)$\nSe \\(H_{1}: \\mu_{X} - \\mu_{Y} &gt; \\mu_{0}\\), \\(p-valor = P\\left ( T &gt; T_{obs} \\mid H_{0}\\right )\\)\nSe \\(H_{1}: \\mu_{X} - \\mu_{Y} &lt; \\mu_{0}\\), \\(p-valor = P\\left ( T &lt; T_{obs} \\mid H_{obs} \\right )\\)\n\nonde\n\\(T_{obs} = \\frac{ (\\bar{X} - \\bar{Y}) - \\mu_{0} }{ \\sqrt{S^2{comb} \\left ( \\frac{1}{n{X}} + \\frac{1}{n_{Y}} \\right ) } }\\)\nquando as variâncias são iguais, ou\n\\(T_{obs} = \\frac{ (\\bar{X} - \\bar{Y}) - \\mu_{0} }{ \\sqrt{ \\frac{S^2{X}}{n{X}} + \\frac{S^2{Y}}{n{Y}} } }\\)\nquando as variâncias são diferentes.\nPara realizar esses cálculos no Python, utilizaremos a função ttest_ind() da biblioteca statsmodels, cujos argumentos de entrada são:\n\nx1: amostra X.\nx2: amostra Y.\nvalue: valor de \\({\\mu_{0}}\\).\nalternative: ‘two-sided’ (default): H1: diferença entre as médias é diferente que value; ‘larger’: H1: diferença entre as médias é maior que value; ‘smaller’: H1: diferença entre as médias é menor que value.\nusevar: ‘pooled’ se as variâncias são iguais, ‘unequal’ se as variâncias são diferentes.\n\nEssa função retornará a estatística de teste, o pvalor e os graus de liberdade, respectivamente.\nAgora vamos aplicar alguns exemplos práticos de forma a demonstrar a facilidade da aplicabilidade da função e dos conceitos estatísticos já apresentados. Utilizaremos o banco de dados de avaliações de filmes.\n\nExemplo 1\nQueremos avaliar se a média dos orçamentos dos filmes de Ação e Aventura são iguais, ao nível de significância de 5%:\nAs hipóteses serão as seguintes:\n\\(H_{0} : \\mu_{X} - \\mu_{Y}  = 0\\)\nvs\n\\(H_{1} : \\mu_{X} - \\mu_{Y}\\neq 0\\)\nOnde X são os orçamentos dos filmes de Ação e Y, os orçamentos dos filmes de Aventura.\nPrimeiro iremos aplicar o teste de razão de variâncias rvar_test para testar a igualdade entre elas. Utilize também o nível de significância de 5%\nrvar_test(x1 = df_acao[\"Budget (million $)\"],x2 = df_adventure[\"Budget (million $)\"],value=1,alternative=\"two-sided\")\n\n\n\n\n\n\n(1.1885458719831832,1.0000000000000000)\n\n\n\nComo p-valor=1 sendo maior que o nível de significância proposto, há evidências de que as varianças são iguais. Agora aplicaremos o teste de comparação de médias considerando as variâncias iguais.\nttest_ind(x1 = df_acao[\"Budget (million $)\"],x2 = df_adventure[\"Budget (million $)\"], alternative = 'two-sided', usevar = 'pooled', value = 0)\n\n\n\n\n\n\n(0.24627191134923368, 0.8057508151994627, 181.0)\n\n\n\nComo p-valor= 0.80 é maior que no nível de significância proposto, não rejeitamos a hipótese nula, ou seja, há evidências de que os orçamentos dos filmes de Ação e Aventura são iguais.\n\n\nExemplo 2\nA revista “The Hollywood Reporter” afirmou que a média dos orçamentos dos filmes de Ação é superior à média dos orçamentos dos filmes de Comédia. Deseja-se avaliar a veracidade dessa informação, ao nível de significância de 5%.\nAs hipóteses serão as seguintes:\n\\(H_{0} : \\mu_{X} - \\mu_{Y}  = 0\\)\nvs\n\\(H_{1} : \\mu_{X} - \\mu_{Y}\\ &gt; 0\\) \\(\\Rightarrow\\) \\(H_{1} : \\mu_{X} &gt; \\mu_{Y}\\)\nOnde X são os orçamentos dos filmes de Ação e Y, os orçamentos dos filmes de Comédia.\ndf_comedia = df[df[\"Genre\"] == 'Comedy']\ndf_comedia.head()\n\n\n\n\n\n\n\nFilm\nGenre\nRotten Tomatoes Ratings %\nAudience Ratings %\nBudget (million $)\nYear of release\nGenre_Comedy\nGenre_Adventure\n\n\n\n\n0\n(500) Days of Summer\nComedy\n87\n81\n8\n2009\n1\n0\n\n\n4\n17 Again\nComedy\n55\n70\n20\n2009\n1\n0\n\n\n6\n27 Dresses\nComedy\n40\n71\n30\n2008\n1\n0\n\n\n8\n30 Minutes or Less\nComedy\n43\n48\n28\n2011\n1\n0\n\n\n9\n50/50\nComedy\n93\n93\n8\n2011\n1\n0\n\n\n\n\n\nPrimeiro iremos aplicar o teste de razão de variâncias rvar_test para testar a igualdade entre elas. Utilize o nível de significância de 5%.\nrvar_test(x1 = df_acao[\"Budget (million $)\"], x2= df_comedia[\"Budget (million $)\"],value=1,alternative=\"larger\")\n\n\n\n\n\n\n(5.6148884065672879,0.0000000000000001)\n\n\n\nComo o p-valor é menor que o nível de significância proposto, temos que as variâncias são diferentes. Agora realizaremos o teste de comparação de médias considerando variâncias diferentes.\nttest_ind(x1 = df_acao[\"Budget (million $)\"],x2 = df_comedia[\"Budget (million $)\"], alternative = 'two-sided', usevar = 'unequal', value = 0)\n\n\n\n\n\n\n(8.765572657433554, 7.820570304870018e-16, 201.07797410706948)\n\n\n\nComo p-valor é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, há evidências de que a média dos orçamentos dos filmes de Ação é superior à média dos orçamentos dos filmes de Comédia.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-comparação-de-médias-para-duas-populações-dependentes",
    "href": "TesteDeHipotesesParte1.html#teste-de-hipótese-para-comparação-de-médias-para-duas-populações-dependentes",
    "title": "Teste de Hipóteses - Parte 1",
    "section": "Teste de Hipótese para Comparação de Médias para Duas Populações Dependentes",
    "text": "Teste de Hipótese para Comparação de Médias para Duas Populações Dependentes\nSejam \\({X \\sim N(µ_{X}, σ^2{X})}\\) e \\({Y \\sim N(µ{Y}, σ^2{Y})}\\) duas amostras pareadas tal que consideramos os pares \\({(X{1}, Y_{1}), \\ …, \\ (X_{n}, Y_{n})}\\). Definindo \\({D = X - Y}\\), temos que \\({D \\sim N(µ_{D}, σ^2{D})}\\), com \\({µ{d} = µ_{X} - µ_{Y}}\\). Assim,\n\\(T= \\frac{\\bar{D} - \\mu}{\\sqrt{\\frac{S^2{D}}{n}}} \\sim t{n-1}\\)\nonde,\n\\(D_{i} = X_{i} - Y_{i}\\) e \\(\\bar{D} = \\sum_{i = 1}^{n} \\frac{D_{i}}{n}\\)\nAssim como nos outros casos, existirão 3 hipóteses possíveis, e suas formas de calcular o pvalor:\n\n\\(H_{0}: \\mu_{D} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{D} \\neq \\mu_{0}\\)\n\\(H_{0}: \\mu_{D} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{D} &gt; \\mu_{0}\\)\n\\(H_{0}: \\mu_{D} = \\mu_{0} \\ \\ \\times \\ \\ H_{1}: \\mu_{D} &lt; \\mu_{0}\\)\n\nSe \\(H_{1}: \\mu_{D} \\neq \\mu_{0}\\),\n$p-valor = P (\\left    T \\right    &gt;\\left  T_{obs} \\right  \\mid H_{0})$\nSe \\(H_{1}: \\mu_{D} &gt; \\mu_{0}\\), \\(p-valor = P (T &gt; T_{obs}\\mid H_{0})\\)\nSe \\(H_{1}: \\mu_{D} &lt; \\mu_{0}\\), \\(p-valor = P (T &lt; T_{obs}\\mid H_{0})\\)\nonde\n\\(T_{obs}= \\frac{\\bar{D} - \\mu_{0}}{\\sqrt{\\frac{S^2_{D}}{n}}}\\)\nDefinindo \\({D = X - Y}\\), temos o caso de Teste de Hipótese para Média de uma população. Portanto, após obtermos D, podemos aplicar as funções ttest_1samp e ttest_uni já apresentadas no material.\nPara aplicações, utilizaremos o banco de dados que representa uma amostra aleatória simples de 198 pessoas. Essa base representa um experimento sobre os efeitos do medicamento ansiolíticos na utilização da memória.\ndata = pd.read_csv(\"Islander_data.csv\")\ndata.head()\n\n\n\n\n\n\n\nfirst_name\nlast_name\nage\nHappy_Sad_group\nDosage\nDrug\nMem_Score_Before\nMem_Score_After\nDiff\n\n\n\n\n0\nBastian\nCarrasco\n25\nH\n1\nA\n63.5\n61.2\n-2.3\n\n\n1\nEvan\nCarrasco\n52\nS\n1\nA\n41.6\n40.7\n-0.9\n\n\n2\nFlorencia\nCarrasco\n29\nH\n1\nA\n59.7\n55.1\n-4.6\n\n\n3\nHolly\nCarrasco\n50\nS\n1\nA\n51.7\n51.2\n-0.5\n\n\n4\nJustin\nCarrasco\n52\nH\n1\nA\n47.0\n47.1\n0.1\n\n\n\n\n\n\nExemplo 1\nUm experimento foi realizado com moradores de diversas ilhas, onde foi possível testar os efeitos de remédios ansiolíticos no uso da memória. Sabendo que os tempos dos testes de memória, antes e depois, dos moradores expostos ao medicamento A seguem uma distribuição normal com média e variância desconhecidas, deseja-se avaliar se a droga A afeta o uso da memória, seja positivamente ou negativamente, observando a diferença do tempo do teste de memória antes e depois da exposição ao medicamento, ao nível de significância de 5%.\nAs hipótetes serão as seguintes:\n\\(H_{0} : \\mu_{X} - \\mu_{Y}  = 0\\) \\(\\Rightarrow\\) \\(H_{0} : \\mu_{D}  = 0\\)\nvs\n\\(H_{1} : \\mu_{X} - \\mu_{Y} \\neq 0\\) \\(\\Rightarrow\\) \\(H_{1} : \\mu_{D} \\neq 0\\)\nOnde D é a diferença entre o tempo de resposta do teste depois (X) e antes (Y) do uso da droga A.\ndata_A = data[data['Drug'] == 'A']\ndata_A.head()\n\n\n\n\n\n\n\nfirst_name\nlast_name\nage\nHappy_Sad_group\nDosage\nDrug\nMem_Score_Before\nMem_Score_After\nDiff\n\n\n\n\n0\nBastian\nCarrasco\n25\nH\n1\nA\n63.5\n61.2\n-2.3\n\n\n1\nEvan\nCarrasco\n52\nS\n1\nA\n41.6\n40.7\n-0.9\n\n\n2\nFlorencia\nCarrasco\n29\nH\n1\nA\n59.7\n55.1\n-4.6\n\n\n3\nHolly\nCarrasco\n50\nS\n1\nA\n51.7\n51.2\n-0.5\n\n\n4\nJustin\nCarrasco\n52\nH\n1\nA\n47.0\n47.1\n0.1\n\n\n\n\n\nUtilizaremos a variável Diff que já contém os valores das diferenças dos tempos de resposta dos testes de memórias, sendo calculado da forma: Diff = Mem_Score_After - Mem_Score_Before.\nss.ttest_1samp(a = data_A['Diff'], popmean =  0)\nTtest_1sampResult(statistic=5.848567939730841, pvalue=1.6898179935298675e-07)\nComo p-valor é menor que no nível de significância proposto, rejeitamos a hipótese nula, ou seja, há evidências de que o medicamento afeta, seja positivamente ou negativamente, o uso da memória.\n\n\nExemplo 2\nDado que no exemplo anterior as médias dos tempos foram considerados diferentes, iremos avaliar se a droga A afeta o uso da memória positivamente, ao nível de significância de 1%.\nAs hipótetes serão as seguintes:\n\\(H_{0} : \\mu_{X} - \\mu_{Y}  = 0\\) \\(\\Rightarrow\\) \\(H_{0} : \\mu_{D}  = 0\\)\nvs\n\\(H_{1} : \\mu_{X} - \\mu_{Y} &gt; 0\\) \\(\\Rightarrow\\) \\(H_{1} : \\mu_{D} &gt; 0\\)\nOnde D é a diferença entre o tempo de resposta do teste depois (X) e antes (Y) do uso da droga A.\nttest_uni(amostra = data_A['Diff'],popmean = 0, alternative = \"larger\")\n\n\n\n\n\n\n(5.8485679397308408, 0.0000000844908996)\n\n\n\nComo p-valor é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, há evidências de que o tempo de resposta do teste depois do uso do medicamento foi maior do que antes. Portanto, tem-se que o medicamento A afeta positivamente o uso da memória.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 1</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html",
    "href": "TesteDeHipotesesParte2.html",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "",
    "text": "Importação",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#exemplo",
    "href": "TesteDeHipotesesParte2.html#exemplo",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Exemplo",
    "text": "Exemplo\nDeseja-se saber se a variabilidade das notas dos críticos do site Rotten Tomatoes são iguais nos filmes dos gêneros Comédia, Ação, Aventura e Drama, ao nível de significância de 5%.\n(?)\nvs\n(?)\ndf_acao, df_adventure, df_comedia, df_drama = df[df[\"Genre\"] == 'Action'], df[df[\"Genre\"] == 'Adventure'], df[df[\"Genre\"] == \"Comedy\"], df[df[\"Genre\"]==\"Drama\"]\nss.levene(df_acao['Rotten Tomatoes Ratings %'],df_adventure['Rotten Tomatoes Ratings %'], df_drama['Rotten Tomatoes Ratings %'], df_comedia['Rotten Tomatoes Ratings %'], center=\"mean\")\n\n\n\n\n\n\nLeveneResult(statistic=1.6923208903592077, pvalue=0.16786851919967521)\n\n\n\nComo p-valor=0.16 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, há evidências de que as variâncias das avaliações dos filmes dos gêneros Comédia, Ação, Drama e Aventura são iguais.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#exemplo-1",
    "href": "TesteDeHipotesesParte2.html#exemplo-1",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Exemplo",
    "text": "Exemplo\nDeseja-se verificar se as médias dos avaliações do site Rotten Tomatoes são iguais para os filmes de Ação, Comédia, Drama e Aventura, utilizando um nível de significância de 5%.\n\\(H_{0} : \\mu_{Ação} = \\mu_{Comédia} = \\mu_{Drama} = \\mu_{Aventura}\\)\nvs\n\\(H_{1} : \\mu_{i} \\neq \\mu_{j}\\) para algum \\(i \\neq j, \\space\\space\\space    onde \\space i,j = {Ação,Aventura,Comédia,Drama}\\)\nPrimeiro passo a ser realizado é verificar se as variâncias são iguais, aplicando o Teste de Levene. Logo, através da aplicação no exemplo anterior, temos que as variâncias são consideradas iguais. Agora realizaremos o teste de ANOVA.\nss.f_oneway(df_acao['Rotten Tomatoes Ratings %'],df_adventure['Rotten Tomatoes Ratings %'],df_drama['Rotten Tomatoes Ratings %'], df_comedia['Rotten Tomatoes Ratings %'])\n\n\n\n\n\n\nF_onewayResult(statistic=6.039948218319176, pvalue=0.0004869684243719264)\n\n\n\nComo p-valor é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, pelo menos uma das médias é considerada diferente. Para saber quais médias são diferentes, realize um teste de comparações múltiplas.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#exemplo-2",
    "href": "TesteDeHipotesesParte2.html#exemplo-2",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Exemplo",
    "text": "Exemplo\nDeseja-se saber se as avaliações da audiência constada no site Rotten Tomatoes para os filmes de Aventura são provenientes de uma distribuição normal, utilizando um nível de significância de 5%.\nss.shapiro(df_adventure['Audience Ratings %'])\n\n\n\n\n\n\n(0.9456037282943726, 0.14058126509189606)\n\n\n\nComo p-valor=0.14 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, podemos afirmar que a amostra é proveniente de uma população com distribuição normal.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#exemplo-1-1",
    "href": "TesteDeHipotesesParte2.html#exemplo-1-1",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Exemplo 1",
    "text": "Exemplo 1\nDeseja-se verificar se as avaliações da audiência constada no site Rotten Tomatoes para os filmes de Terror são provenientes de uma distribuição normal, utilizando um nível de significância de 5%.\n\\(H_{0}\\): os dados seguem uma distribuição normal\nvs\n\\(H_{1}\\): os dados não seguem uma distribuição normal\ndf_horror = df[df[\"Genre\"] == 'Horror']\ndf_horror.head()\n\n\n\n\nFilm\nGenre\nRotten Tomatoes Ratings %\nAudience Ratings %\nBudget (million $)\nYear of release\n\n\n\n\n7\n30 Days of Night\nHorror\n50\n57\n32\n2007\n\n\n12\nA Nightmare on Elm Street\nHorror\n13\n40\n35\n2010\n\n\n20\nAlien vs. Predator -- Requiem\nHorror\n14\n37\n40\n2007\n\n\n28\nApollo 18\nHorror\n23\n31\n5\n2011\n\n\n59\nCase 39\nHorror\n23\n42\n26\n2009\n\n\n\nss.kstest(df_horror['Audience Ratings %'], \"norm\", args=[np.mean(df_horror['Audience Ratings %']),np.std(df_horror['Audience Ratings %'])])\n\n\n\n\n\n\nKstestResult(statistic=0.05351444278807435, pvalue=0.9989829445848811)\n\n\n\nComo p-valor = 0.99 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, há evidências de que os dados são provenientes de uma normal.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#exemplo-2-1",
    "href": "TesteDeHipotesesParte2.html#exemplo-2-1",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Exemplo 2",
    "text": "Exemplo 2\nDeseja-se verificar se as avaliações da audiência constadas no site Rotten Tomatoes para os filmes de Terror possuem a mesma distribuição do que as avaliações da audiência para os filmes de Ação, utilizando um nível de significância de 5%.\n\\(H_{0}\\): os dados seguem a mesma distribuição.\nvs\n\\(H_{1}\\): os dados não seguem a mesma distribuição.\nComo p-valor=0.004 é menor que o nível de significância proposto, rejeitamos a hipótese nula, ou seja, as avaliações da audiência para os filmes de Terror e Ação não seguem a mesma distribuição.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#teste-de-aderência",
    "href": "TesteDeHipotesesParte2.html#teste-de-aderência",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Teste de Aderência",
    "text": "Teste de Aderência\nO teste de Aderência busca avaliar o comportamento, em uma população, de uma variável categórica que pode assumir k valores. Sejam \\(p_{1}, p_{2}, p_{3},…, p_{k}\\), respectivamente, as proporções populacionais das categorias \\(1, 2, 3, …, K\\), teremos as seguintes hipóteses:\n\\(H_{0} : p_{1} = p_{1,A} \\ , \\ p_{2} = p_{2,A} \\ , \\ p_{3} = p_{3,A} \\ … \\ p_{k} = p_{k,A}\\)\nvs\n$H_{1} : p_{i} p_{i,A}  , $, para pelo menos um \\(i \\ , \\ i = 1, 2, 3, …, k\\)\nOnde \\(p_{i,A}; i = 1, 2, · · · , k\\) são as proporções da hipótese nula, que devem satisfazer \\(\\sum\\limits_{i = 1}^k p_{i,A} = 1\\)\nSob \\(H_{0}\\):\n\\(X^2 = \\sum_{i = 1}^{k}\\frac{(o_{i} - e_{i})^2}{e_{i}} \\sim X^2_{k-1}\\)\nOnde:\n\n\\(o_{i}\\): é o número de vezes que a categoria \\(i\\) é observada na amostra\n\\(e_{i}\\): valor esperado; obtido pela multiplicação do tamanho da amostra com \\(p_{i}\\)\n\nE o p-valor é calculado da seguinte forma:\nPara o teste de Aderência usaremos a função chisquare da biblioteca Scipy, cujos argumentos de entrada são\n\nf_obs: amostra observada\nf_exp: valores esperados, sob \\(H_{0}\\)\n\nPara mais informações sobre a função clique aqui para acessar sua documentação.\n\nExemplo\nDeseja-se verificar se a proporção de filmes de Aventura, Romance e Suspense avaliados são, respectivamente, 0.26, 0.29, 0.45, ao nível de significância de 5%.\n\\(H_{0} : p_{1} = 0.26 \\ , \\ p_{2} = 0.29 \\ , \\ p_{3} = 0.45\\)\nvs\n$H_{1} : p_{i} p_{i,A}  , $, para pelo menos um \\(i \\ , \\ i = 1, 2, 3\\)\nObtendo os valores observados:\ntabela_freq = df.Genre.value_counts()\ntabela_freq\n\n\n\n\n\n\nComedy 172 Action 154 Drama 101 Horror 49 Thriller 36 Adventure 29 Romance 21 Name: Genre, dtype: int64\n\n\n\nAplicando a função:\nobs = [tabela_freq[5], tabela_freq[6], tabela_freq[4]]\ntotal_obs = sum(obs)\n\nchisquare(f_obs = obs, f_exp = [0.26*total_obs, 0.29*total_obs, 0.45*total_obs])\n\n\n\n\n\n\nPower_divergenceResult(statistic=2.782616741718586, pvalue=0.24874963485619836)\n\n\n\nComo p-valor=0.25 é maior que o nível de significância proposto, não rejeitamos a hipótese nula, ou seja, podemos afirmar que a proporção de filmes de Aventura, Romance e Suspense avaliados são respectivamente de 0.26,0.29 e 0.45.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#teste-de-homogeneidade",
    "href": "TesteDeHipotesesParte2.html#teste-de-homogeneidade",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Teste de Homogeneidade",
    "text": "Teste de Homogeneidade\nEsse caso é similar ao teste de Aderência, com a diferença de que agora será avaliado o comportamento, em C populações independentes, de uma variável categórica que pode assumir L valores.\nPara este teste, teremos as seguintes hipóteses:\n\\(H_{0} : p_{1, 1} = p_{1, 2} = … = p_{1, C} \\ ; \\ p_{2, 1} = p_{2, 2} = … = p_{2, C} \\ ; \\ \\ … \\ \\ ; \\ p_{L, 1} = p_{L, 2} = … = p_{L, C}\\)\nvs\n\\(H_{1} :\\) pelo menos uma das igualdades não é valida\nPara temos que:\n\\(X^2 = \\sum_{i = 1}^{L}\\sum_{j = 1}^{C}\\frac{(o_{ij - e_{ij}})^2}{e_{ij}} \\sim X^2_{(L - 1)*(C - 1)}\\)\nOnde:\n\n\\(o_{ij} :\\) número de vezes que na amostra da população \\(i\\) a categoria \\(j\\) é observada.\n\\(e_{ij} :\\) valor esperado na população e na categoria \\(j\\)\n\nE o p-valor é calculado da seguinte forma:\nPara o teste de Homogeneidade usaremos a função chi2_contingency da biblioteca Scipy, cujo argumento de entrada é\n\nobserved: tabela de contingência\n\n\nExemplo\nCom o intuito de saber a eficacia da quimioterapia para dois diferentes tipos de câncer, um médico selecionou de maneira aleatória 100 pacientes com o câncer do Tipo I e 100 com o Tipo II, e dispôs os resultados na tabela abaixo. Verifique se existe relação entre a eficacia da quimioterapia e o tipo de câncer, ao nível de significância de 5%.\n\n\n  \n    \n    \n    Reação\n    \n  \n\n\n  \n  \n    Câncer\n    Pouca\n    Média\n    Alta\n  \n  \n  \n    Tipo I\n    51\n    33\n    16\n  \n  \n  \n    Tipo II\n    58\n    29\n    13\n  \n  \n\n\ntabela_cancer = np.array([51, 33, 16, 58, 29, 13]).reshape(2,3)\ntabela_cancer\n\n\n\n\n\n\narray([[51, 33, 16],[58, 29, 13]])\n\n\n\nchi2_contingency(tabela_cancer)\n\n\n\n\n\n\n(1.0179506281189088, 0.6011112135514984, 2, array([[54.5, 31. , 14.5],[54.5, 31. , 14.5]]))\n\n\n\nComo p-valor = 0.6011 é maior que o nível de significância, não rejeitamos a hipótese nula. Ou seja, há evidências de que o efeito da quimioterapia é igual para os dois tipos de câncer observados.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  },
  {
    "objectID": "TesteDeHipotesesParte2.html#teste-de-independência",
    "href": "TesteDeHipotesesParte2.html#teste-de-independência",
    "title": "Teste de Hipóteses - Parte 2",
    "section": "Teste de Independência",
    "text": "Teste de Independência\nAgora considere que cada indivíduo da amostra será classificado conforme duas variáveis qualitativas. Em comparação ao teste de Homogeneidade, e simplificando o entendimento, ao invés de L populações, teremos uma população que pode ser classificada de Lformas diferentes.\nPara este teste teremos as seguintes hipóteses:\n\\(H_{0} : p_{i\\bigcap j} = p_{i.}*p_{.j}\\), para todo \\(i = 1, …, L\\) e \\(j = 1, …, C\\)\nvs\n\\(H_{1} :\\) pelo menos uma das igualdades não é valida\nOnde \\(p_{i\\bigcap j}\\) é a probabilidade do indivíduo ser classificado como \\(i\\) e \\(j\\) simultaneamente e \\(p_{i.}\\) e \\(p_{.j}\\) as probabilidades dos indivíduos serem classificados como \\(i\\) ou \\(j\\) de forma separada, respectivamente.\nPara e sob temos que:\n\\(X^2 = \\sum_{i = 1}^{L}\\sum_{j = 1}^{C}\\frac{(o_{ij - e_{ij}})^2}{e_{ij}} \\sim X^2_{(L - 1)*(C - 1)}\\)\nE o p-valor é calculado da seguinte forma:\nTodo desenvolvimento do cálculo será igual ao teste de Homogeneidade, mas a interpretação do problema será diferente, assim como as hipóteses.\n\nExemplo\nAgora, o médico gostaria de avaliar se a reação à quimioterapia independe do tipo de câncer do paciente. Para tanto, foram selecionados 180 pacientes que fazem tratamento de câncer com quimioterapia e suas informações foram dispostas na tabela abaixo. Verifique se “Tipo de câncer” e “Eficacia da quimioterapia” são variáveis independentes, ao nível de significância de 5%.\n\n\n  \n    \n    \n    Reação\n    \n  \n\n\n  \n  \n    Câncer\n    Pouca\n    Média\n    Alta\n  \n  \n\n\n  \n    Tipo III\n    38\n    32\n    30\n  \n  \n    Tipo IV\n    26\n    38\n    16\n  \n\n\ntabela_cancer = np.array([38, 32, 30, 26, 38, 16]).reshape(2,3)\ntabela_cancer\n\n\n\n\n\n\narray([[38, 32, 30],[26, 38, 16]])\n\n\n\nchi2_contingency(tabela_cancer)\n\n\n\n\n\n\n(4.862969720496892, 0.08790620719349594, 2, array([[35.55555556, 38.88888889, 25.55555556], [28.44444444, 31.11111111, 20.44444444]]))\n\n\n\nComo p-valor = 0.0879 é maior que o nível de significância, não rejeitamos a hipótese nula. Ou seja, há evidências de que “Tipo de câncer” e “Eficacia da quimioterapia” são variáveis independentes.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Teste de Hipóteses - Parte 2</span>"
    ]
  }
]